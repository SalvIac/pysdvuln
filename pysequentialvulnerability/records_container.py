# -*- coding: utf-8 -*-
"""
@author: Salvatore
"""

import os
from glob import glob
import warnings
from copy import deepcopy
from tqdm import tqdm
import numpy as np
from scipy import interpolate
from scipy.io import loadmat
from scipy.stats import qmc
import matplotlib.pyplot as plt
from pysequentialvulnerability.record import Record



class RecordsContainer():
    
    def __init__(self, sourcepath, seed=1992):
        self.sourcepath = sourcepath
        self.records = list()
        self.load_goda_records()
        self.load_simbad_records()
        self.excluded = list()
        self.inconsistent_t_steps()
        self.ims = dict()
        self.spectra = dict()
        self.interp_spectra = dict()
        np.random.seed(seed)
        
        
    def load_simbad_records(self):
        print("upload simbad records")
        path_records = os.path.join(self.sourcepath, "SIMBAD (Updated 2011)", 
                                    "Records")
        path_spectra = os.path.join(self.sourcepath, "SIMBAD (Updated 2011)",
                                    "Spectra")
        all_record_paths = glob(os.path.join(path_records,"*.mat"))
        for path in tqdm(all_record_paths):
            filename = os.path.basename(path)
            if "za_" not in filename:
                spectrum_name = filename.replace("_record", "")
                spectrum_path = os.path.join(path_spectra, spectrum_name)
                rec = Record.load_simbad_record(path, allinfo=True,
                                                spectrum_path=spectrum_path)
                self.records.append(rec)
            

    def load_goda_records(self):
        print("upload records by goda")
        path_records = os.path.join(self.sourcepath, 
                                    "MS-AS sequences by Katsu Goda")
        all_record_paths = glob(os.path.join(path_records,"*.dat"))
        other_path = os.path.join(path_records, "MSASinfo.mat")
        data = loadmat(other_path)
        for path in tqdm(all_record_paths):
            if os.path.basename(path).split("_")[0] == "MS":
                rec = Record.load_goda_record(path, allinfo=True, data=data)
                self.records.append(rec)
    
    
    def inconsistent_t_steps(self):
        t_steps = list()
        for gmr in self.records:
            t_steps.append(gmr.t_step)
        min_t_step = min(t_steps)
        remain0 = [t_step % min_t_step == 0 for t_step in t_steps]
        if any(remain0):
            inds = np.where(remain0)[0][::-1]
            string = "\n".join([str(self.records[i]) for i in inds])
            warnings.warn("following ground-motion records excluded because of t_step:\n"+string)
            for i in inds:
                self.excluded.append(deepcopy(self.records[i]))
                del self.records[i]
    
    
    def check_duplicates(self):
        r0 = self.get_sas(0.)
        r0r = np.round(r0, 4)
        u, c = np.unique(r0r, return_counts=True)
        dup = u[c > 1]
        todelete = list()
        periods = [0.01, 0.05, 0.075, 0.1, 0.2, 0.5, 1., 2.]
        for d in tqdm(dup):
            inds = np.where(r0r == d)[0]
            sref = self.records[inds[0]].generate_response_spectrum(periods)
            for ind in inds[1:]:
                sche = self.records[ind].generate_response_spectrum(periods)
                # ax = self.records[inds[0]].plot_response_spectrum()
                # self.records[ind].plot_response_spectrum(ax=ax)
                if np.mean(np.power(sref-sche, 2)) < 1e-4:
                    todelete.append(ind)
        return todelete
    

    def delete_records(self, inds):
        if not hasattr(inds, '__iter__'):
            inds = [inds]
        inds = sorted(inds)
        for i in inds[::-1]:
            self.excluded.append(deepcopy(self.records[i]))
            for key in ["spectra", "interp_spectra"]:
                if self.records[i] in self.__dict__[key].keys():
                    del self.__dict__[key][self.records[i]]
            del self.records[i]
        for key in ["ims"]:
            for key2 in self.__dict__[key].keys():
                self.__dict__[key][key2] = np.delete(self.__dict__[key][key2], inds)


    def get_num_records(self):
        return len(self.records)


    def get_sa(self, rec, period):
            if period == 0.:
                return rec.pga
            else:
                if rec not in self.interp_spectra.keys():
                    self.interp_spectra[rec] = self.get_interp_spectra(rec)
                return self.interp_spectra[rec](period)


    def get_avgsa(self, rec, struct_period):
        '''
        The avgSa, selected here as IM, is conventionally calculated by
        considering a range of 10 equally-spaced periods spanning 
        approximately from a lower bound of 0.2T1 and an upper bound of 1.5T1,
        where T1 is the fundamental period of the structure (e.g., Kohrangi et 
        al. 2016).
        '''
        lower_period = 0.2*struct_period
        upper_period = 1.5*struct_period
        periods = np.linspace(lower_period, upper_period, 10)
        if rec not in self.interp_spectra.keys():
            self.interp_spectra[rec] = self.get_interp_spectra(rec)
        return np.mean( self.interp_spectra[rec](periods) )


    def get_sas(self, period):
        if period == 0.:
            key = "PGA"
        else:
            key = "SA({:.1f})".format(period)
        if key in self.ims.keys():
            return self.ims[key]
        ims = list()
        for rec in self.records:
            ims.append(self.get_sa(rec, period))
        self.ims[key] = np.array(ims)
        return self.ims[key]
    
    
    def get_avgsas(self, struct_period):
        key = "avgSA({:.2f})".format(struct_period)
        if key in self.ims.keys():
            return self.ims[key]
        ims = list()
        for rec in self.records:
            ims.append(self.get_avgsa(rec, struct_period))
        self.ims[key] = np.array(ims)
        return self.ims[key]
    
    
    @classmethod
    def get_interp_spectra(cls, rec):
        '''
        spectra is a 2d nump array (n,2), with n number of response periods
        '''
        spectrum = rec.get_spectrum()
        f = interpolate.interp1d(spectrum[:,0], spectrum[:,1])
        return f
    
    
    def get_pair_combos(self, ims, plot=False, imt="IM (m/s2)"):
        ''' all pair combination '''
        _max = np.ceil(ims.max()*100)/100
        combos = list()
        for i1 in ims:
            for i2 in ims:
                combos.append([i1, i2])
        combos = np.array(combos)
        if plot:
            fig = plt.figure(figsize=(6,6))
            plt.scatter(combos[:,0], combos[:,1], s=5, edgecolor='k', linewidth=0.1)
            plt.xlabel("GM1 {}".format(imt))
            plt.ylabel("GM2 {}".format(imt))
            plt.show()
        return combos
    

    def get_distr_im(self, ims, numbins=50, plot=False, imt="IM (m/s2)"):
        ''' actual distribution of IMs '''
        _max = np.ceil(ims.max()*100)/100
        bins = np.linspace(0., _max, numbins+1)
        hist, _ = np.histogram(ims, bins=bins)
        actual_probs = hist/np.sum(hist)
        if plot:
            cents = bins[:-1] + np.diff(bins)/2
            fig, ax = plt.subplots(2,1)
            ax[0].bar(cents, actual_probs, width=0.95*np.diff(bins), edgecolor='k')
            ax[0].set_ylabel("PMF")
            # ax[0].set_yscale("log")
            ax[1].bar(cents, np.cumsum(actual_probs), width=0.95*np.diff(bins), edgecolor='k')
            ax[1].set_xlabel(imt)
            ax[1].set_ylabel("CDF")
            plt.show()            
        return actual_probs, bins


    def get_distr_indeces(self, ims, numbins=50):
        ''' actual distribution of IMs '''
        _, bins = self.get_distr_im(ims, numbins)
        indeces = list()
        for e, edge in enumerate(bins[:-1]):
            indeces.append(list())
            for i, val in enumerate(ims):
                if edge <= val < bins[e+1]:
                    indeces[-1].append(i)
        return indeces


    def sample1d_ind(self, ims, num=500):
        ''' sampling with with indeces '''
        ranges = np.linspace(-0.5, ims.shape[0]-0.5, num+1)
        inds = [int(np.round(np.random.uniform(rang, ranges[i+1]))) 
                for i, rang in enumerate(ranges[:-1])]
        sampled_ims = ims[inds]
        return sampled_ims
        
    
    def sample2d_ind(self, ims, num=500, plot=False, imt="IM (m/s2)"):
        ''' 2d sampling with indeces '''
        ranges = np.linspace(-0.5, ims.shape[0]-0.5, num+1)
        inds = [int(np.round(np.random.uniform(rang, ranges[i+1])))
                for i, rang in enumerate(ranges[:-1])]
        ims1 = ims[inds]
        np.random.shuffle(ims1)
        inds = [int(np.round(np.random.uniform(rang, ranges[i+1])))
                for i, rang in enumerate(ranges[:-1])]
        ims2 = ims[inds]
        np.random.shuffle(ims2)
        # combine
        combos_ims = list()
        for i1, i2 in zip(ims1, ims2):
            combos_ims.append([i1, i2])
        combos_ims = np.array(combos_ims)
        if plot:
            fig = plt.figure(figsize=(6,6))
            plt.scatter(combos_ims[:,0], combos_ims[:,1], s=5, edgecolor='k', linewidth=0.1)
            plt.xlabel("GM1 {}".format(imt))
            plt.ylabel("GM2 {}".format(imt))
            plt.show()
        return combos_ims


    def sample1d_im(self, ims, num=500, numbins=50):
        ''' sampling with with IMs '''
        sampler = qmc.LatinHypercube(d=1)
        sample = sampler.random(n=num)
        # actual probability distribution of ims
        indeces = self.get_distr_indeces(ims, numbins=numbins)
        actual_probs, _ = self.get_distr_im(ims, numbins=numbins, plot=False)
        cumprobs = np.cumsum(actual_probs)
        # index
        inds1d = np.searchsorted(cumprobs, sample)
        sample1d = list()
        for row in inds1d:
            # sample CMF
            if len(indeces[row[0]]) == 0:
                stop
            ind = np.random.choice(indeces[row[0]])
            sample1d.append(ims[ind])
        sample1d = np.array(sample1d)
        return sample1d
        

    def sample2d_im(self, ims, num=500, numbins=50, plot=False, imt="IM (m/s2)"):
        ''' 2d Latin Hypercube with IMs '''
        sampler = qmc.LatinHypercube(d=2)
        sample = sampler.random(n=num)
        # qmc.discrepancy(sample)
        # actual probability distribution of ims
        indeces = self.get_distr_indeces(ims, numbins=numbins)
        actual_probs, _ = self.get_distr_im(ims, numbins=numbins, plot=False)
        cumprobs = np.cumsum(actual_probs)
        # index
        inds2d = np.searchsorted(cumprobs, sample)
        sample2d = list()
        for row in inds2d:
            # sample CMF twice
            temp = list()
            for i in range(0,2):
                if len(indeces[row[i]]) == 0:
                    stop
                ind = np.random.choice(indeces[row[i]])
                temp.append(ims[ind])
            sample2d.append(temp)
        sample2d = np.array(sample2d)
        if plot:
            # fig = plt.figure(figsize=(6,6))
            # plt.scatter(sample[:,0], sample[:,1], s=5, edgecolor='k', linewidth=0.1)
            # plt.xlabel("epsilon1")
            # plt.ylabel("epsilon2")
            # plt.show()
            fig = plt.figure(figsize=(6,6))
            plt.scatter(sample2d[:,0], sample2d[:,1], s=5, edgecolor='k', linewidth=0.1)
            plt.xlabel("GM1 {}".format(imt))
            plt.ylabel("GM2 {}".format(imt))
            plt.show()
        return sample2d
    
    
    def plot_all_spectra(self, unit="g", x_scale="linear"):
        fig, ax = plt.subplots()
        ax.set_xlabel("Period (s)")
        if unit == "g":
            ax.set_ylabel("Acceleration (g)")
        elif unit == "m/s2":
            ax.set_ylabel("Acceleration (m/s2)")
        else:
            raise Exception("unit can only be 'g' or 'm/s2'")
        for rec in self.records:
            spec = rec.get_spectrum()
            if unit == "g":
                spec[:,1] = spec[:,1]/9.81
            ax.plot(spec[:,0], spec[:,1], linewidth=0.5, color=[0.5,0.5,0.5])
        ax.set_xscale(x_scale)
        plt.show()
    
    
    
    def combine_gmrs(self, gmrs, time_between=40):
        
        return 
    
    
    
    def __repr__(self):
        return self.__str__()
        
    def __str__(self):
        return "<{} ".format(self.__class__.__name__) + \
               str(self.get_num_records()) + " records>"
   
    # def __iter__(self):
    #     self.__n = 0
    #     return self

    # def __next__(self):
    #     if self.__n < self.num_catalogs:
    #         ob = self[self.__n]
    #         self.__n += 1
    #         return ob
    #     else:
    #         raise StopIteration
    
    # def __getitem__(self, i):
    #     ob = self.gmf_catalogs[i]
    #     if isinstance(ob, list):
    #         for o in ob:
    #             if o.sites is None:
    #                 o.sites = self.sites
    #             if o.imts is None:
    #                 o.imts = self.imts
    #     else:
    #         if ob.sites is None:
    #             ob.sites = self.sites
    #         if ob.imts is None:
    #             ob.imts = self.imts
    #     return ob

    