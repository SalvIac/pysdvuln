# -*- coding: utf-8 -*-
"""
@author: Salvatore
"""

import os
import numpy as np
import pandas as pd
from scipy.interpolate import LinearNDInterpolator
import matplotlib.pyplot as plt
from matplotlib import cm


class Vuln3d():
    
    def __init__(self, ddvc):
        self.ddvc = ddvc
        points = list()
        z = list()
        # mainshock-only
        ims = ddvc.get_ims(unit="g")
        vuln = ddvc.get_vuln_curve_ds1(ds1=0)
        for i1, i2, i3 in zip(ims, [0.]*len(ims), vuln):
            points.append( (i1,i2) )
            z.append(i3)
        for i1, i2, i3 in zip([0.]*len(ims), ims, vuln):
            points.append( (i1,i2) )
            z.append(i3)
        # state-dependent
        for ds1 in range(1, len(ddvc.vulns.keys())):
            vuln1 = ddvc.get_vuln_curve_ds1(ds1=ds1)
            for i1, i2, i3 in zip([ims[np.searchsorted(vuln, vuln1[0])]]*len(ims), ims, vuln1):
                points.append( (i1,i2) )
                z.append(i3)
        self.X = ims #np.linspace(0.05, 3.1, 100)
        self.Y = ims #np.linspace(0.05, 3.1, 100)
        X, Y = np.meshgrid(self.X, self.Y)
        interp = LinearNDInterpolator(points, z)
        self.Z = interp(X, Y)
        self.Z[np.isnan(self.Z)] = 1.
    
    
    def get_vuln_3d_df(self):
        return pd.DataFrame(data=self.Z, index=self.X, columns=self.Y)
    

    def plot_vuln_surf(self, unit="g", imt="IM", save=False, path="",
                       max_img=None):
        X, Y = np.meshgrid(self.X, self.Y)
        if max_img is None:
            max_img = np.max(X)+1e-3
        cond = np.logical_and(X <= max_img, Y <= max_img)
        inds = np.where(cond)
        n = int(np.sqrt(np.sum(cond)))
        
        # 3d hysteretic energy GM1+GM2 vs max drift GM1 vs IMs GM2
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        ims = self.X
        vuln = self.ddvc.get_vuln_curve_ds1(ds1=0)
        ax.plot(ims[ims<=max_img],
                [0.]*len(ims[ims<=max_img]),
                vuln[ims<=max_img], color="k", lw=2, zorder=200)
        ax.plot([0.]*len(ims[ims<=max_img]),
                ims[ims<=max_img],
                vuln[ims<=max_img], color="k", lw=2, zorder=200)
        for ds1 in range(1,4):
            vuln1 = self.ddvc.get_vuln_curve_ds1(ds1=ds1)
            ax.plot([ims[np.searchsorted(vuln, vuln1[0])]]*len(ims[ims<=max_img]),
                    ims[ims<=max_img], vuln1[ims<=max_img],
                    color="k", lw=2, zorder=200)
        surf = ax.plot_surface(X[inds[0], inds[1]].reshape(n,n),
                               Y[inds[0], inds[1]].reshape(n,n),
                               self.Z[inds[0], inds[1]].reshape(n,n),
                               cmap=cm.coolwarm, linewidth=0,
                               antialiased=False, alpha=0.5)
        ax.contour(X[inds[0], inds[1]].reshape(n,n),
                   Y[inds[0], inds[1]].reshape(n,n),
                   self.Z[inds[0], inds[1]].reshape(n,n),
                   zdir='z', offset=0.01,
                   cmap=cm.coolwarm)
        ax.set_xlabel('{} G1 ({})'.format(imt, unit))
        ax.set_ylabel('{} G2 ({})'.format(imt, unit))
        ax.set_zlabel("$E(LR | IM_{G1}, IM_{G2})$") #'Loss Ratio')
        ax.set_xlim([0.,max_img])
        ax.set_ylim([0.,max_img])
        ax.set_zlim([0.,1.])
        ax.view_init(elev=25, azim=-140)
        if save:
            fig.savefig(os.path.join(path, "vuln_3d.png"),
                        bbox_inches='tight', dpi=600, format="png")
        else:
            plt.show()
        
