# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
from scipy.stats import norm
from scipy.stats import lognorm
from scipy.optimize import curve_fit
from pyvulnerability.damg_dep_frag_curves_noc import DamgDepFragCurvesNoC
from pyvulnerability.prob_collapse import ProbCollapse


def log(x, s, scale):
    return lognorm.cdf(x, s, 0., scale)


class DamgDepFragCurves(DamgDepFragCurvesNoC):
    
    def __init__(self, psdm, dsc, sigmab2b=0.):
        super().__init__(psdm, dsc, sigmab2b)
        self.pc = ProbCollapse(psdm)


    def get_prob_coll(self, ims, ds1=0, unit="g"):
        if unit == "g":
            ims_g = ims
        else:
            ims_g = ims/9.81
        thresh = self.dsc.get_ds_thresh(ds1) # displacement-based threshold
        if thresh == 0.:
            thresh = 1e-15
        return self.pc(thresh*np.ones_like(ims_g), ims_g)
        

    def get_prob_no_coll(self, ims, ds1=0, unit="g"):
        return 1. - self.get_prob_coll(ims, ds1, unit)


    def get_fragility(self, ims, ds2, ds1=0, unit="m/s2"):
        '''
        this is tricky, everything else is done with IM in m/s2, while the
        alphas from Jalayer et al. (2017) use g.
        '''
        if unit == "g":
            ims = ims*9.81 # convert to m/s2
        mu, beta = self.get_frag_params(ds2, ds1, original=True)
        return norm.cdf((np.log(ims) - np.log(mu))/beta) * \
               self.get_prob_no_coll(ims, ds1, unit="m/s2") + \
               self.get_prob_coll(ims, ds1, unit="m/s2")


    def get_frag_params(self, ds2, ds1=0, unit="m/s2", original=False):
        '''
        ds1 = 0 returns the mainshock fragility
        ds1 != 0 returns the aftershock fragility for ds2
        '''
        if original:
            return super().get_frag_params(ds2, ds1, unit)
        if ds2 == 0:
            raise Exception("check ds2, it cannot be zero")
        if unit == "g":
            x_ims = self.x_ims_g
        else:
            x_ims = self.x_ims_ms2
        P_ds = self.get_fragility(x_ims, ds2, ds1, unit)
        popt, pcov = curve_fit(log, x_ims, P_ds, p0=[0.1, 1.])
        return popt[1], popt[0]


    def check_plots(self, unit="m/s2", imt="IM"):
        self.pc.check_plots()
        super().check_plots(unit, imt)
        
                   
    def __repr__(self):
        return self.__str__()
        
    def __str__(self):
        return "<{}>".format(self.__class__.__name__)
        

