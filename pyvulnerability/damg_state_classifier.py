# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt


class DamgStateClassifier():
    '''
    damage states from capacity according to Martins and Silva (2020)
    '''
    def __init__(self, thresholds=None, capacity_curve=None, cov=None):
        if capacity_curve is not None and thresholds is not None:
            raise Exception("specify thresholds or capacity_curve")
        if capacity_curve is not None:
            self.thresholds = self.get_displ_thresholds(capacity_curve)
        elif thresholds is not None:
            if isinstance(thresholds, np.ndarray):
                thresholds = thresholds.tolist()
            self.thresholds = thresholds
        else:
            raise Exception("cannot specify both thresholds and capacity_curve")
        # randomize thresholds according to lognormal distribution
        if cov is not None:
            self.cov = cov
            self.randomize = True
        else:
            self.randomize = False
            

    @classmethod
    def get_displ_thresholds(cls, capacity_curve):
        '''
        capacity curve defined as Sa[g]-Sd[m]
        displacement thresholds defined according to Martins and Silva (2020)
        '''
        if capacity_curve.shape[0] == 3:
            dy = capacity_curve[1,0]
        else:
            dy = capacity_curve[2,0]
        du = capacity_curve[-1,0]
        thresholds = [0.75*dy, 0.5*dy+0.33*du, 0.25*dy+0.67*du, du]
        return thresholds

    
    def get_thresholds(self, size=1):
        if not self.randomize:
            return self.thresholds #+[1e9]
        else:
            mus = self.thresholds
            sigmas = np.array(mus)*self.cov
            out = list()
            for mu, sigma in zip(mus, sigmas):
                out.append(np.exp(norm.rvs(loc=np.log(mu), scale=sigma, size=size)))
            return np.array(out)


    def classify(self, drift):
        if not self.randomize:
            return np.searchsorted(self.thresholds, drift)
        else:
            out = list()
            thresholds = self.get_thresholds(len(drift))
            for d, drif in enumerate(drift):
                out.append( np.searchsorted(thresholds[:,d], drif) )
            return np.array(out)
    
    
    def get_damage_states(self):
        return np.arange(0, len(self.thresholds)+1)
    
    
    def get_damage_states_str(self):
        ds = self.get_damage_states()
        return ["DS{}".format(d) for d in ds]

    
    def get_ds_thresh(self, ds):
        if ds == 0:
            # DS=0 means undamaged structure
            return 0.
        return self.thresholds[ds-1]
    
    
    def __repr__(self):
        return self.__str__()
        
    def __str__(self):
        return "<{}, thresholds: {}, randomize: {}>".format(self.__class__.__name__,
                                                            self.thresholds,
                                                            self.randomize)

    
    def check_plots(self):
        thresholds = self.get_thresholds(1000)
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        for i in range(len(self.thresholds)):
            hist, bins = np.histogram(thresholds[i,:], bins=20)
            xs = (bins[:-1] + bins[1:])/2
            ax.bar(xs, hist, zs=i, zdir='y', width=0.9*np.min(np.diff(bins)),
                   alpha=0.8)
        plt.show()

        
        # for i in range(len(self.thresholds)):
        #     fig, ax = plt.subplots()
        #     hist, bins = np.histogram(thresholds[i,:], bins=20)
        #     xs = (bins[:-1] + bins[1:])/2
        #     ax.bar(xs, hist, , alpha=0.8)
        # plt.show()    
    