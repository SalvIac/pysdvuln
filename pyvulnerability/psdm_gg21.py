# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from matplotlib import cm

class PSDM_gg21():
    
    def __init__(self, analyses):
        maxds_g1 = list()
        hysts_g1 = list()
        ims_g1 = list()
        maxds_g2 = list()
        hysts_g2 = list()
        ims_g2 = list()
        for an in analyses:
            rt = an["rp"].end_rest_time
            maxds_g1.append( an["opr"].get_max_disp( end=rt ) )
            hysts_g1.append( an["opr"].calculate_hyst_energy( end=rt ) )
            maxds_g2.append( an["opr"].get_max_disp( start=rt ) - maxds_g1[-1] )
            hysts_g2.append( an["opr"].calculate_hyst_energy( start=rt ) )
            ims_g2.append( an["im_g2"] )
            ims_g1.append( an["im_g1"] ) 
        self.maxds_g1 = np.abs(maxds_g1)
        self.hysts_g1 = np.abs(hysts_g1)
        self.ims_g1 = np.abs(ims_g1)
        self.maxds_g2 = np.abs(maxds_g2)
        self.hysts_g2 = np.abs(hysts_g2)
        self.ims_g2 = np.abs(ims_g2)
        # filter for "collapse" cases for mainshock
        filt_g1 = self.maxds_g1 < 0.1
        filt_g2 = self.maxds_g2 < 0.1
        filt = np.logical_and(filt_g1, filt_g2)
        self.maxds_g1 = self.maxds_g1[filt]
        self.hysts_g1 = self.hysts_g1[filt]
        self.ims_g1 = self.ims_g1[filt]
        self.maxds_g2 = self.maxds_g2[filt]
        self.hysts_g2 = self.hysts_g2[filt]
        self.ims_g2 = self.ims_g2[filt]
        # 1. Using the MS data only (ðœƒð‘€ð‘†, ð¸ð»,ð‘€ð‘†), the relationship ð‘Žðœƒð‘
        # ð‘€ð‘† is fitted. The parameters ð‘Ž and ð‘ are estimated via the
        # linear least squares method in the log-log space.
        (a, b), pcov = curve_fit(self.power_law,
                                 self.maxds_g1, self.hysts_g1)
        # 2. Using the MS data only (ð¼ð‘€ð‘€ð‘†, ð¸ð»,ð‘€ð‘†), the relationship ð‘0ð¼ð‘€ð‘‘
        # ð´ð‘† is fitted. The parameters ð‘0 and ð‘‘ are estimated as per point 1.
        (c0, d), pcov = curve_fit(self.power_law, 
                                  self.ims_g1, self.hysts_g1)
        # 3. Using the AS data (ðœƒð‘€ð‘†, ð¼ ð‘€ð´ð‘†, ð¸ð»,ð´ð‘†), the parameter ð‘š is
        # estimated via the nonlinear least squares to the function
        # ð¸ð»,ð´ð‘† = (1âˆ’ð‘šðœƒð‘€ð‘†) ð‘0ð¼ð‘€ð‘‘ð´ð‘†.
        m, pcov = curve_fit(lambda x, m: self.power_law_gm2_2d(x, c0, d, m),
                            np.vstack([self.maxds_g2, self.ims_g2]).T,
                            self.hysts_g2)
        self.a = a
        self.b = b
        self.c0 = c0
        self.d = d
        self.m = m[0]
        

    @classmethod
    def power_law(cls, x, a, b):
        # simple power law model
        return a*np.power(x, b)    
    
    @classmethod
    def power_law_2d(cls, data, a, b, c0, d, m):
        '''
        proposed by Gentile and Galasso (2021)
        data: 2d numpy array with col1 gm1_max_drift and col2 gm2_ims
        a, b, c0, d, m are 5 parameters
        '''
        return cls.power_law_gm1(data[:,0], a, b) + \
               cls.power_law_gm2_2d(data, c0, d, m)
    
    @classmethod
    def power_law_gm1(cls, gm1_max_drift, a, b):
        # to model hysteretic energy for gm1 (e.g., a mainshock)
        return a * np.power(gm1_max_drift, b)
        
    @classmethod
    def power_law_gm2_2d(cls, data, c0, d, m):
        # to model hysteretic energy for gm2 (e.g., an aftershock)
        # data: 2d numpy array with col1 gm1_max_drift and col2 gm2_ims
        gm1_max_drift = data[:,0]
        gm2_ims = data[:,1]
        return (1 - m * gm1_max_drift) * c0 * np.power(gm2_ims, d)


    def get_params(self):
        return self.a, self.b, self.c0, self.d, self.m


    def check_plots(self):
        '''
        thieseplots are similar to the ones in Gentile and Galasso (2021)
        '''
        # 2d hysteretic energy vs max drift ground motion 1 (mainshock)
        fig, ax = plt.subplots()
        ax.scatter(self.maxds_g1, self.hysts_g1, s=2, color="r")
        ax.plot(np.sort(self.maxds_g1),
                self.power_law(np.sort(self.maxds_g1), self.a, self.b),
                color="k")
        ax.set_xlabel('Max drift GM1 (%)')
        ax.set_ylabel('Hysteretic Energy GM1 (kNm)')
        # ax.set_xscale("log")
        # ax.set_yscale("log")
        plt.show()

        # 3d hysteretic energy vs max drift ground motion 1 (mainshock)
        # fig = plt.figure()
        # ax = fig.add_subplot(projection='3d')
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        ax.scatter([0.]*len(self.ims_g2), self.maxds_g1, self.hysts_g1,
                   s=2, color="r")
        ax.plot([0.]*len(self.ims_g2), np.sort(self.maxds_g1),
                self.power_law(np.sort(self.maxds_g1), self.a, self.b),
                color="k")
        ax.set_xlabel('IMs GM2 (m/s2)')
        ax.set_ylabel('Max drift GM1 (%)')
        ax.set_zlabel('Hysteretic Energy GM1 (kNm)')
        ax.set_xlim([0, max(self.ims_g2)])
        plt.show()
        
        # 2d hysteretic energy vs max drift ground motion 2 (aftershock)
        fig, ax = plt.subplots()
        ax.scatter(self.ims_g1, self.hysts_g1, s=2, color="b")
        ax.plot(np.sort(self.ims_g1),
                self.power_law(np.sort(self.ims_g1), self.c0, self.d),
                color="k")
        ax.set_xlabel('IMs GM2 (m/s2)')
        ax.set_ylabel('Hysteretic Energy GM1 (kNm)')
        # ax.set_xscale("log")
        # ax.set_yscale("log")
        plt.show()

        # 3d hysteretic energy GM2 vs max drift GM1 vs IMs GM2 (aftershock)
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        ax.scatter(self.ims_g2, self.maxds_g2, self.hysts_g2, 
                   s=2, color="m")
        ax.scatter(self.ims_g1, [0.]*len(self.maxds_g1), self.hysts_g1,
                   s=2, color="b")
        ax.plot(np.sort(self.ims_g1), [0.]*len(self.ims_g1),
                self.power_law(np.sort(self.ims_g1), self.c0, self.d),
                color="k")
        ax.set_xlabel('IMs GM2 (m/s2)')
        ax.set_ylabel('Max drift GM1 (%)')
        ax.set_zlabel('Hysteretic Energy GM2 (kNm)')
        plt.show()
        
        # 3d hysteretic energy GM1+GM2 vs max drift GM1 vs IMs GM2
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        X = np.arange(0, np.max(self.ims_g2), 0.01)
        Y = np.arange(0, np.max(self.maxds_g1), 0.01)
        X, Y = np.meshgrid(X, Y)
        R = self.power_law_2d(np.vstack([Y.flatten(), X.flatten()]).T,
                                  self.a, self.b, self.c0, self.d, self.m)
        Z = R.reshape(X.shape)
        ax.scatter(self.ims_g2, self.maxds_g1, self.hysts_g1+self.hysts_g2, 
                   s=2, color="m")
        surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,
                               linewidth=0, antialiased=False, alpha=0.5)
        ax.plot([0.]*len(self.maxds_g1), np.sort(self.maxds_g1),
                self.power_law(np.sort(self.maxds_g1), self.a, self.b),
                color="k", lw=2, zorder=200)
        ax.plot(np.sort(self.ims_g1), [0.]*len(self.ims_g1), 
                self.power_law(np.sort(self.ims_g1), self.c0, self.d),
                color="k", lw=2, zorder=200)
        plt.show()
        
    #%%
    
    # param, param_cov = curve_fit(power_law, maxds, hysts)
    # x = np.linspace(0., max(maxds))
    # y = power_law(x, param[0], param[1])
    
    # fig = plt.figure(figsize=(6,6))
    # plt.scatter(maxds, hysts, s=5, edgecolor='k', linewidth=0.1)
    # plt.plot(x, y, color='k', linewidth=1)
    # plt.xlabel("max displacement")
    # plt.ylabel("hysteretic energy")
    # plt.show()
