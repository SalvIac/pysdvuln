# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
from matplotlib import cm


class PSDM_gg21():

    def __init__(self, maxds_g1, ims_g1, hysts_g1, maxds_g2, ims_g2, hysts_g2, 
                 dam_state_cl, collapses=None, zero_tol=1e-3):
        self.maxds_g1 = np.abs(maxds_g1)
        self.hysts_g1 = np.abs(hysts_g1)
        self.ims_g1 = np.abs(ims_g1)
        self.maxds_g2 = np.abs(maxds_g2)
        self.hysts_g2 = np.abs(hysts_g2)
        self.ims_g2 = np.abs(ims_g2)
        self.hysts_g12 = self.hysts_g1 + self.hysts_g2
        # classify
        self.dam_state_cl = dam_state_cl
        self.ds_g1 = dam_state_cl.classify(self.maxds_g1)
        self.ds_g2 = np.clip(dam_state_cl.classify(self.maxds_g2), self.ds_g1, None)
        # filter for "collapse" cases for mainshock
        if collapses is not None:
            self.nocoll_g1 = ~collapses # self.ds_g2 != 4 # self.maxds_g1 <= 1.*dam_state_cl.thresholds[-1]
            self.nocoll_g2 = ~collapses # self.ds_g2 != 4 # self.maxds_g2 <= 1.*dam_state_cl.thresholds[-1]
        else:
            self.nocoll_g1 = self.ds_g2 != 4 # self.maxds_g1 <= 1.*dam_state_cl.thresholds[-1]
            self.nocoll_g2 = self.ds_g2 != 4 # self.maxds_g2 <= 1.*dam_state_cl.thresholds[-1]
        # tolerance for zero hysteretic energy
        self.ZERO_TOL = zero_tol
        # 1. Using the MS data only (ðœƒð‘€ð‘†, ð¸ð»,ð‘€ð‘†), the relationship ð‘Žðœƒð‘
        # ð‘€ð‘† is fitted. The parameters ð‘Ž and ð‘ are estimated via the
        # linear least squares method in the log-log space.
        # filter zero hysteretic energy
        self.filt_en_g1 = self.hysts_g1 > self.ZERO_TOL
        filt_g1 = np.logical_and(self.nocoll_g1, self.filt_en_g1)
        # (a, b), pcov = curve_fit(self.power_law,
        #                          self.maxds_g1[filt_g1],
        #                          self.hysts_g1[filt_g1])
        # (a, b), pcov = curve_fit(self.linear_model,
        #                           np.log10(self.maxds_g1[filt_g1]),
        #                           np.log10(self.hysts_g1[filt_g1]))
        # a = 10**a
        reg = LinearRegression().fit(np.log10(self.maxds_g1[filt_g1]).reshape(-1, 1),
                                     np.log10(self.hysts_g1[filt_g1]))
        a = 10**reg.intercept_
        b = reg.coef_[0]
        # e MS data only (ð¼ð‘€ð‘€ð‘†, ð¸ð»,ð‘€ð‘†), the relationship ð‘0ð¼ð‘€ð‘‘
        # ð´ð‘† is fitted. The parameters ð‘0 and ð‘‘ are estimated as per point 1.
        # (c0, d), pcov = curve_fit(self.power_law, 
        #                           self.ims_g1[filt_g1],
        #                           self.hysts_g1[filt_g1])
        # (c0, d), pcov = curve_fit(self.linear_model,
        #                           np.log10(self.ims_g1[filt_g1]),
        #                           np.log10(self.hysts_g1[filt_g1]))
        # c0 = 10**c0
        reg = LinearRegression().fit(np.log10(self.ims_g1[filt_g1]).reshape(-1, 1),
                                     np.log10(self.hysts_g1[filt_g1]))
        c0 = 10**reg.intercept_
        d = reg.coef_[0]
        # 3. Using the AS data (ðœƒð‘€ð‘†, ð¼ ð‘€ð´ð‘†, ð¸ð»,ð´ð‘†), the parameter ð‘š is
        # estimated via the nonlinear least squares to the function
        # ð¸ð»,ð´ð‘† = (1âˆ’ð‘šðœƒð‘€ð‘†) ð‘0ð¼ð‘€ð‘‘ð´ð‘†.
        # filter zero hysteretic energy
        self.filt_en_g2 = self.hysts_g2 > self.ZERO_TOL
        filt_g2 = np.logical_and(self.nocoll_g2, self.filt_en_g2)
        m, pcov = curve_fit(lambda x, m: self.power_law_gm2_2d(x, c0, d, m),
                            np.vstack([self.maxds_g1[filt_g2], 
                                        self.ims_g2[filt_g2]]).T,
                            self.hysts_g2[filt_g2])
        self.a = a
        self.b = b
        self.c0 = c0
        self.d = d
        self.m = m[0]
    
    
    @classmethod
    def from_analyses(cls, analyses, dam_state_cl, zero_tol=1e-3):
        maxds_g1 = list()
        hysts_g1 = list()
        ims_g1 = list()
        maxds_g2 = list()
        hysts_g2 = list()
        ims_g2 = list()
        hysts_g12 = list()
        for an in analyses:
            rt = an["rp"].end_rest_time
            maxds_g1.append( an["opr"].get_max_disp( end=rt ) )
            hysts_g1.append( an["opr"].calculate_hyst_energy( end=rt ) )
            ims_g1.append( an["im_g1"] )
            maxds_g2.append( an["opr"].get_max_disp( start=rt ) - maxds_g1[-1] )
            hysts_g2.append( an["opr"].calculate_hyst_energy( start=rt ) )
            ims_g2.append( an["im_g2"] )
            hysts_g12.append( an["opr"].calculate_hyst_energy() )
        return cls(maxds_g1, ims_g1, hysts_g1, maxds_g2, ims_g2, hysts_g2,
                   dam_state_cl, zero_tol=zero_tol)
        
    
    @classmethod
    def power_law(cls, x, a, b):
        # simple power law model
        return a*np.power(x, b)

    @classmethod
    def linear_model(cls, x, a, b):
        return a + b*x

    @classmethod
    def power_law_2d(cls, data, a, b, c0, d, m):
        '''
        proposed by Gentile and Galasso (2021)
        data: 2d numpy array with col1 gm1_max_drift and col2 gm2_ims
        a, b, c0, d, m are 5 parameters
        '''
        return cls.power_law_gm1(data[:,0], a, b) + \
               cls.power_law_gm2_2d(data, c0, d, m)
    
    @classmethod
    def power_law_gm1(cls, gm1_max_drift, a, b):
        # to model hysteretic energy for gm1 (e.g., a mainshock)
        return a * np.power(gm1_max_drift, b)
        
    @classmethod
    def power_law_gm2_2d(cls, data, c0, d, m):
        # to model hysteretic energy for gm2 (e.g., an aftershock)
        # data: 2d numpy array with col1 gm1_max_drift and col2 gm2_ims
        gm1_max_drift = data[:,0]
        gm2_ims = data[:,1]
        return (1 - m * gm1_max_drift) * c0 * np.power(gm2_ims, d)


    @classmethod
    def log_power_law_gm2_2d(cls, data, c0, d, m):
        # log of power_law_gm2_2d
        gm1_max_drift = data[:,0]
        gm2_ims = data[:,1]
        return np.log(1 - m * gm1_max_drift) + np.log(c0) + d*np.log(gm2_ims)



    def get_params(self):
        return self.a, self.b, self.c0, self.d, self.m


    def get_params_df(self):
        data = {"a": self.a,
                "b": self.b,
                "c0": self.c0,
                "d": self.d,
                "m": self.m}
        return pd.DataFrame(data, index=[0]).T


    def check_plots(self):
        '''
        these plots are similar to the ones in Gentile and Galasso (2021)
        '''
        
        filt_g1 = np.logical_and(self.nocoll_g1, self.filt_en_g1)
        filt_g2 = np.logical_and(self.nocoll_g2, self.filt_en_g2)
        ds_states = 
        ds_colors = cm.coolwarm([0,1,2,3,4]) #["c", "g", "m", "b", "r"]
        
        
        # plot IM-gm1 and IM-gm2 scatter 2d
        fig, ax = plt.subplots(figsize=(6,6))
        ax.scatter(self.ims_g1, self.ims_g2,
                   s=5, lw=0.5, marker="o", edgecolors='k', c='gray')
        ax.set_xlabel(r'IM GM1')
        ax.set_ylabel(r'IM GM2')


        # plot IM-gm1, IM-gm2 and hyst12 scatter 3d
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        ax.scatter(self.ims_g1[filt_g2], self.ims_g2[filt_g2], self.hysts_g1[filt_g2],
                   s=5, lw=0.5, marker="o", edgecolors='k', c='gray')
        ax.set_xlabel(r'IM GM1')
        ax.set_ylabel(r'IM GM2')
        ax.set_zlabel('Total Hysteretic Energy')

        
        # 2d hysteretic energy vs max drift ground motion 1 (mainshock)
        fig, ax = plt.subplots()
        for ds, col in zip([0,1,2,3,4], ds_colors):
            ax.scatter(self.maxds_g1[filt_g1][self.ds_g1[filt_g1]==ds],
                       self.hysts_g1[filt_g1][self.ds_g1[filt_g1]==ds],
                       s=2, color=col, label="DS"+str(ds))
        xs = np.linspace(0., np.max(self.maxds_g1[filt_g1]), 100)
        ax.plot(xs, self.power_law(xs, self.a, self.b), color="k")
        ax.set_xlabel('Max drift GM1')
        ax.set_ylabel('Hysteretic Energy GM1')
        ax.legend()
        ax.set_xscale("log")
        ax.set_yscale("log")


        # 3d hysteretic energy vs max drift ground motion 1 (mainshock)
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        for ds, col in zip([0,1,2,3,4], ds_colors):
            # ax.scatter(self.maxds_g1[filt_g1][self.ds_g1[filt_g1]==ds],
            #            self.hysts_g1[filt_g1][self.ds_g1[filt_g1]==ds], s=2, 
            #            color=col, label="DS"+str(ds))
            ax.scatter([0.]*len(self.ims_g1[filt_g1][self.ds_g1[filt_g1]==ds]),
                       self.maxds_g1[filt_g1][self.ds_g1[filt_g1]==ds],
                       self.hysts_g1[filt_g1][self.ds_g1[filt_g1]==ds],
                       s=2, color=col, label="DS"+str(ds))
        xs = np.linspace(0., np.max(self.maxds_g1[filt_g1]), 100)
        ax.plot([0.]*len(xs), xs, self.power_law(xs, self.a, self.b),
                color="k")
        ax.set_xlabel('IM GM2') # (m/s2)
        ax.set_ylabel('Max drift GM1') # (m)
        ax.set_zlabel('Hysteretic Energy GM1') # (Nm)
        ax.set_xlim([0, max(self.ims_g2)])
        ax.legend()
        ax.view_init(elev=25, azim=-140)
        

        # 2d hysteretic energy vs max drift ground motion 2 (aftershock)
        fig, ax = plt.subplots()
        for ds, col in zip([0,1,2,3,4], ds_colors):
            ax.scatter(self.ims_g1[filt_g1][self.ds_g1[filt_g1]==ds],
                       self.hysts_g1[filt_g1][self.ds_g1[filt_g1]==ds], s=2, color=col,
                       label="DS"+str(ds))
        xs = np.linspace(0., np.max(self.ims_g1[filt_g1]), 100)
        ax.plot(xs, self.power_law(xs, self.c0, self.d), color="k")
        ax.set_xlabel('IM GM1') # (m/s2)
        ax.set_ylabel('Hysteretic Energy GM1') # (Nm)
        ax.legend()
        ax.set_xscale("log")
        ax.set_yscale("log")


        # 3d hysteretic energy GM2 vs max drift GM1 vs IMs GM2 (aftershock)
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        ax.scatter(self.ims_g2[filt_g2],
                   self.maxds_g1[filt_g2],
                   self.hysts_g2[filt_g2],
                   s=2, color="m")
        ax.scatter(self.ims_g1[filt_g1],
                   [0.]*len(self.maxds_g1[filt_g1]),
                   self.hysts_g1[filt_g1],
                   s=2, color="b")
        xs = np.linspace(0., np.max(self.ims_g1[filt_g1]), 100)
        ax.plot(xs, [0.]*len(xs), self.power_law(xs, self.c0, self.d),
                color="k")
        ax.set_xlabel('IM GM2') # (m/s2)
        ax.set_ylabel('Max drift GM1') # (m)
        ax.set_zlabel('Hysteretic Energy GM2') # (Nm)
        ax.view_init(elev=25, azim=-140)
        

        # 3d hysteretic energy GM1+GM2 vs max drift GM1 vs IMs GM2
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        X = np.linspace(0, np.max(self.ims_g2[filt_g2]), 20)
        Y = np.linspace(0, np.max(self.maxds_g1[filt_g2]), 20)
        X, Y = np.meshgrid(X, Y)
        R = self(Y.flatten(), X.flatten())
        Z = R.reshape(X.shape)
        ax.scatter(self.ims_g2[self.nocoll_g2], self.maxds_g1[self.nocoll_g2],
                   self.hysts_g12[self.nocoll_g2], s=2, color="m")
        # ax.scatter(self.ims_g2, self.maxds_g1, self.hysts_g12, s=2, color="g")
        surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,
                               linewidth=0, antialiased=False, alpha=0.5)
        xs = np.linspace(0., np.max(self.maxds_g1[filt_g2]), 100)
        ax.plot([0.]*len(xs), xs, self.power_law(xs, self.a, self.b),
                color="k", lw=2, zorder=200)
        xs = np.linspace(0., np.max(self.ims_g2[filt_g2]), 100)
        ax.plot(xs, [0.]*len(xs), self.power_law(xs, self.c0, self.d),
                color="k", lw=2, zorder=200)
        ax.set_xlabel('IM GM2')
        ax.set_ylabel('Max drift GM1')
        ax.set_zlabel('Total Hysteretic Energy')
        ax.view_init(elev=25, azim=-140)
        plt.show()
    
    

    def __call__(self, gm1_max_drift, gm2_ims):
        return self.power_law_2d(np.vstack([gm1_max_drift, gm2_ims]).T,
                                 self.a, self.b, self.c0, self.d, self.m)
    
    
    def __repr__(self):
        return self.__str__()
        
    def __str__(self):
        return "<{}>".format(self.__class__.__name__)
    
    
    #%%
    
    # param, param_cov = curve_fit(power_law, maxds, hysts)
    # x = np.linspace(0., max(maxds))
    # y = power_law(x, param[0], param[1])
    
    # fig = plt.figure(figsize=(6,6))
    # plt.scatter(maxds, hysts, s=5, edgecolor='k', linewidth=0.1)
    # plt.plot(x, y, color='k', linewidth=1)
    # plt.xlabel("max displacement")
    # plt.ylabel("hysteretic energy")
    # plt.show()
