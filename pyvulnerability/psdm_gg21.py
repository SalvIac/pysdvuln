# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from matplotlib import cm

class PSDM_gg21():
    
    def __init__(self, analyses, dam_state_cl):
        maxds_g1 = list()
        hysts_g1 = list()
        ims_g1 = list()
        maxds_g2 = list()
        hysts_g2 = list()
        ims_g2 = list()
        hysts_g12 = list()
        for an in analyses:
            rt = an["rp"].end_rest_time
            maxds_g1.append( an["opr"].get_max_disp( end=rt ) )
            hysts_g1.append( an["opr"].calculate_hyst_energy( end=rt ) )
            ims_g1.append( an["im_g1"] )
            maxds_g2.append( an["opr"].get_max_disp( start=rt ) - maxds_g1[-1] )
            hysts_g2.append( an["opr"].calculate_hyst_energy( start=rt ) )
            ims_g2.append( an["im_g2"] )
            hysts_g12.append( an["opr"].calculate_hyst_energy() )
        self.maxds_g1 = np.abs(maxds_g1)
        self.hysts_g1 = np.abs(hysts_g1)
        self.ims_g1 = np.abs(ims_g1)
        self.maxds_g2 = np.abs(maxds_g2)
        self.hysts_g2 = np.abs(hysts_g2)
        self.ims_g2 = np.abs(ims_g2)
        self.hysts_g12 = np.abs(hysts_g12)
        # classify
        self.dam_state_cl = dam_state_cl
        self.ds_g1 = dam_state_cl.classify(self.maxds_g1)
        self.ds_g2 = np.clip(dam_state_cl.classify(self.maxds_g2), self.ds_g1, None)
        # filter for "collapse" cases for mainshock
        self.collapse_g1 = self.ds_g1 != 4
        self.collapse_g2 = self.ds_g2 != 4
        # 1. Using the MS data only (𝜃𝑀𝑆, 𝐸𝐻,𝑀𝑆), the relationship 𝑎𝜃𝑏
        # 𝑀𝑆 is fitted. The parameters 𝑎 and 𝑏 are estimated via the
        # linear least squares method in the log-log space.
        (a, b), pcov = curve_fit(self.power_law,
                                 self.maxds_g1[self.collapse_g1],
                                 self.hysts_g1[self.collapse_g1])
        # 2. Using the MS data only (𝐼𝑀𝑀𝑆, 𝐸𝐻,𝑀𝑆), the relationship 𝑐0𝐼𝑀𝑑
        # 𝐴𝑆 is fitted. The parameters 𝑐0 and 𝑑 are estimated as per point 1.
        (c0, d), pcov = curve_fit(self.power_law, 
                                  self.ims_g1[self.collapse_g1],
                                  self.hysts_g1[self.collapse_g1])
        # 3. Using the AS data (𝜃𝑀𝑆, 𝐼 𝑀𝐴𝑆, 𝐸𝐻,𝐴𝑆), the parameter 𝑚 is
        # estimated via the nonlinear least squares to the function
        # 𝐸𝐻,𝐴𝑆 = (1−𝑚𝜃𝑀𝑆) 𝑐0𝐼𝑀𝑑𝐴𝑆.
        m, pcov = curve_fit(lambda x, m: self.power_law_gm2_2d(x, c0, d, m),
                            np.vstack([self.maxds_g1[self.collapse_g2], 
                                       self.ims_g2[self.collapse_g2]]).T,
                            self.hysts_g2[self.collapse_g2])
        self.a = a
        self.b = b
        self.c0 = c0
        self.d = d
        self.m = m[0]
        

    @classmethod
    def power_law(cls, x, a, b):
        # simple power law model
        return a*np.power(x, b)    
    
    @classmethod
    def power_law_2d(cls, data, a, b, c0, d, m):
        '''
        proposed by Gentile and Galasso (2021)
        data: 2d numpy array with col1 gm1_max_drift and col2 gm2_ims
        a, b, c0, d, m are 5 parameters
        '''
        return cls.power_law_gm1(data[:,0], a, b) + \
               cls.power_law_gm2_2d(data, c0, d, m)
    
    @classmethod
    def power_law_gm1(cls, gm1_max_drift, a, b):
        # to model hysteretic energy for gm1 (e.g., a mainshock)
        return a * np.power(gm1_max_drift, b)
        
    @classmethod
    def power_law_gm2_2d(cls, data, c0, d, m):
        # to model hysteretic energy for gm2 (e.g., an aftershock)
        # data: 2d numpy array with col1 gm1_max_drift and col2 gm2_ims
        gm1_max_drift = data[:,0]
        gm2_ims = data[:,1]
        return (1 - m * gm1_max_drift) * c0 * np.power(gm2_ims, d)


    def get_params(self):
        return self.a, self.b, self.c0, self.d, self.m


    def check_plots(self):
        '''
        these plots are similar to the ones in Gentile and Galasso (2021)
        '''
        
        fig, ax = plt.subplots(figsize=(6,6))
        ax.plot(self.ims_g1, self.ims_g2, "o", mec='black', mfc='gray')
        ax.set_xlabel(r'IM GM1 (m/s2)')
        ax.set_ylabel(r'IM GM2 (m/s2)')
        
        # 2d hysteretic energy vs max drift ground motion 1 (mainshock)
        fig, ax = plt.subplots()
        for ds, col in zip([0,1,2,3], ["r", "b", "m", "g"]):
            ax.scatter(self.maxds_g1[self.ds_g1==ds],
                       self.hysts_g1[self.ds_g1==ds], s=2, color=col,
                       label="DS"+str(ds))
        ax.plot(np.sort(self.maxds_g1[self.collapse_g1]),
                self.power_law(np.sort(self.maxds_g1[self.collapse_g1]), self.a, self.b),
                color="k")
        ax.set_xlabel('Max drift GM1 (m)')
        ax.set_ylabel('Hysteretic Energy GM1 (kNm)')
        ax.legend()
        # ax.set_xscale("log")
        # ax.set_yscale("log")

        # 3d hysteretic energy vs max drift ground motion 1 (mainshock)
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        ax.scatter([0.]*len(self.ims_g1[self.collapse_g1]),
                   self.maxds_g1[self.collapse_g1],
                   self.hysts_g1[self.collapse_g1],
                   s=2, color="r")
        ax.plot([0.]*len(self.ims_g1[self.collapse_g1]),
                np.sort(self.maxds_g1[self.collapse_g1]),
                self.power_law(np.sort(self.maxds_g1[self.collapse_g1]), self.a, self.b),
                color="k")
        ax.set_xlabel('IM GM2 (m/s2)')
        ax.set_ylabel('Max drift GM1 (m)')
        ax.set_zlabel('Hysteretic Energy GM1 (kNm)')
        ax.set_xlim([0, max(self.ims_g2)])
        ax.view_init(elev=25, azim=-140)
        
        # 2d hysteretic energy vs max drift ground motion 2 (aftershock)
        fig, ax = plt.subplots()
        for ds, col in zip([0,1,2,3], ["r", "b", "m", "g"]):
            ax.scatter(self.ims_g1[self.ds_g1==ds],
                       self.hysts_g1[self.ds_g1==ds], s=2, color=col,
                       label="DS"+str(ds))
        ax.plot(np.sort(self.ims_g1[self.collapse_g1]),
                self.power_law(np.sort(self.ims_g1[self.collapse_g1]), self.c0, self.d),
                color="k")
        ax.set_xlabel('IM GM1 (m/s2)')
        ax.set_ylabel('Hysteretic Energy GM1 (kNm)')
        ax.legend()
        # ax.set_xscale("log")
        # ax.set_yscale("log")

        # 3d hysteretic energy GM2 vs max drift GM1 vs IMs GM2 (aftershock)
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        ax.scatter(self.ims_g2[self.collapse_g2],
                   self.maxds_g1[self.collapse_g2],
                   self.hysts_g2[self.collapse_g2],
                   s=2, color="m")
        ax.scatter(self.ims_g1[self.collapse_g1],
                   [0.]*len(self.maxds_g1[self.collapse_g1]),
                   self.hysts_g1[self.collapse_g1],
                   s=2, color="b")
        ax.plot(np.sort(self.ims_g1[self.collapse_g1]),
                [0.]*len(self.ims_g1[self.collapse_g1]),
                self.power_law(np.sort(self.ims_g1[self.collapse_g1]), self.c0, self.d),
                color="k")
        ax.set_xlabel('IM GM2 (m/s2)')
        ax.set_ylabel('Max drift GM1 (m)')
        ax.set_zlabel('Hysteretic Energy GM2 (kNm)')
        ax.view_init(elev=25, azim=-140)
        
        # 3d hysteretic energy GM1+GM2 vs max drift GM1 vs IMs GM2
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        X = np.arange(0, np.max(self.ims_g2[self.collapse_g2]), 0.01)
        Y = np.arange(0, np.max(self.maxds_g1[self.collapse_g2]), 0.01)
        X, Y = np.meshgrid(X, Y)
        R = self.power_law_2d(np.vstack([Y.flatten(), X.flatten()]).T,
                                  self.a, self.b, self.c0, self.d, self.m)
        Z = R.reshape(X.shape)
        ax.scatter(self.ims_g2[self.collapse_g2],
                   self.maxds_g1[self.collapse_g2],
                   self.hysts_g12[self.collapse_g2], 
                   s=2, color="m")
        surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,
                               linewidth=0, antialiased=False, alpha=0.5)
        ax.plot([0.]*len(self.maxds_g1[self.collapse_g1]),
                np.sort(self.maxds_g1[self.collapse_g1]),
                self.power_law(np.sort(self.maxds_g1[self.collapse_g1]), self.a, self.b),
                color="k", lw=2, zorder=200)
        ax.plot(np.sort(self.ims_g1[self.collapse_g1]),
                [0.]*len(self.ims_g1[self.collapse_g1]), 
                self.power_law(np.sort(self.ims_g1[self.collapse_g1]), self.c0, self.d),
                color="k", lw=2, zorder=200)
        ax.set_xlabel('IM GM2 (m/s2)')
        ax.set_ylabel('Max drift GM1 (m)')
        ax.set_zlabel('Total Hysteretic Energy (kNm)')
        ax.view_init(elev=25, azim=-140)
        plt.show()
    
    
    def __call__(self, gm1_max_drift, gm2_ims):
        return self.power_law_2d(np.vstack([gm1_max_drift, gm2_ims]).T,
                                 self.a, self.b, self.c0, self.d, self.m)
    
    
    
    
    #%%
    
    # param, param_cov = curve_fit(power_law, maxds, hysts)
    # x = np.linspace(0., max(maxds))
    # y = power_law(x, param[0], param[1])
    
    # fig = plt.figure(figsize=(6,6))
    # plt.scatter(maxds, hysts, s=5, edgecolor='k', linewidth=0.1)
    # plt.plot(x, y, color='k', linewidth=1)
    # plt.xlabel("max displacement")
    # plt.ylabel("hysteretic energy")
    # plt.show()
