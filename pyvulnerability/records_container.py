# -*- coding: utf-8 -*-
"""
@author: Salvatore
"""

import os
from glob import glob
import warnings
from copy import deepcopy
import time
from tqdm import tqdm
import numpy as np
import pandas as pd
from scipy.io import loadmat
from scipy.stats import qmc
from scipy.optimize import dual_annealing
import matplotlib.pyplot as plt
from pyvulnerability.record import Record
from pyvulnerability.record_two_comp import RecordTwoComp, RecordChooseComp


class RecordsContainer():
    
    def __init__(self, records=[], database=None, sourcepath=None, seed=1992):
        self.records = records
        self.sourcepath = sourcepath
        self.database = database
        self.excluded = list()
        self.ims = dict()
        self.spectra = dict()
        self.interp_spectra = dict()
        np.random.seed(seed)
        # if "ngawest2" in databases: #TODO here I could use a callable dict
        #     self.load_ngawest2_records()
        # if "simbad" in databases:
        #     self.load_simbad_records()
        # if "goda" in databases:
        #     self.load_goda_records()
        
    
    @classmethod
    def load_simbad_data(cls, sourcepath):
        path_records = os.path.join(sourcepath, "SIMBAD (Updated 2011)", 
                                    "Records")
        path_spectra = os.path.join(sourcepath, "SIMBAD (Updated 2011)",
                                    "Spectra")
        all_record_paths = glob(os.path.join(path_records,"*.mat"))
        flatfile = os.path.join(sourcepath, "SIMBAD (Updated 2011)",
                                "SIMBAD.xls")
        metadata = pd.read_excel(flatfile)
        records = list()
        for path in tqdm(all_record_paths):
            filename = os.path.basename(path)
            if "za_" not in filename:
                spectrum_name = filename.replace("_record", "")
                spectrum_path = os.path.join(path_spectra, spectrum_name)
                rec = Record.load_simbad_record(path, allinfo=True,
                                                spectrum_path=spectrum_path,
                                                metadata=metadata)
                records.append(rec)
        return cls(records, database="simbad", sourcepath=sourcepath)
    
    
    @classmethod
    def load_ngawest2_data(cls, sourcepath):
        path_records = os.path.join(sourcepath, "NGAWest2", "time_histories")
        all_record_paths = glob(os.path.join(path_records,"*.AT2"))
        metadata = Record.load_ngawest2_flatfile(os.path.join(sourcepath, "NGAWest2"))
        vertical = list()
        for st, rsn in zip(metadata["File Name (Vertical)"], metadata["Record Sequence Number"]):
            if st == -999 or st == "-999":
                continue
            if "\\" in st:
                sym = "\\"
            else:
                sym = "/"
            vertical.append( "RSN"+str(rsn)+"_"+st.replace(sym, "_") )
        records = list()
        for path in tqdm(all_record_paths):
            filename = os.path.basename(path)
            rsn = int(filename.split("_")[0].replace("RSN", ""))
            if "-UP." in filename or "V." in filename or "V1." in filename or \
                "DWN." in filename or "DN." in filename or "UD." in filename or \
                "Z." in filename:
                continue
            if filename not in vertical:
                rec = Record.load_ngawest2_record(path, allinfo=True,
                                                  metadata=metadata)
                records.append(rec)
        return cls(records, database="ngawest2", sourcepath=sourcepath)


    @classmethod
    def load_ngawest2_data_comps(cls, sourcepath):
        path_records = os.path.join(sourcepath, "NGAWest2", "time_histories")
        all_record_paths = glob(os.path.join(path_records,"*.AT2"))
        all_record_filenames = [os.path.basename(path) for path in all_record_paths]
        metadata = Record.load_ngawest2_flatfile(os.path.join(sourcepath, "NGAWest2"))
        records = list()
        for st1, st2, rsn in zip(tqdm(metadata["File Name (Horizontal 1)"]),
                                 metadata["File Name (Horizontal 2)"],
                                 metadata["Record Sequence Number"]):
            if st1 == -999 or st1 == "-999" or st2 == -999 or st2 == "-999":
                continue
            name1 = "RSN"+str(rsn)+"_"+st1.replace("\\", "_").replace("/", "_")
            name2 = "RSN"+str(rsn)+"_"+st2.replace("\\", "_").replace("/", "_")
            if name1 not in all_record_filenames or name2 not in all_record_filenames:
                continue
            rec1 = Record.load_ngawest2_record(os.path.join(path_records, name1),
                                               allinfo=True, metadata=metadata)
            rec2 = Record.load_ngawest2_record(os.path.join(path_records, name2),
                                               allinfo=True, metadata=metadata)
            trec = RecordTwoComp(rec1, rec2)
            records.append(trec)
        return cls(records, database="ngawest2", sourcepath=sourcepath)
    
    
    @classmethod
    def load_goda_data(cls, sourcepath):
        path_records = os.path.join(sourcepath, "MS-AS sequences by Katsu Goda")
        all_record_paths = glob(os.path.join(path_records,"*.dat"))
        other_path = os.path.join(path_records, "MSASinfo.mat")
        data = loadmat(other_path)
        records = list()
        for path in tqdm(all_record_paths):
            if os.path.basename(path).split("_")[0] == "MS":
                rec = Record.load_goda_record(path, allinfo=True, metadata=data)
                records.append(rec)
        return cls(records, database="goda", sourcepath=sourcepath)

    
    def inconsistent_t_steps(self):
        t_steps = list()
        for gmr in self.records:
            t_steps.append(gmr.t_step)
        min_t_step = min(t_steps)
        remain0 = [t_step % min_t_step != 0 for t_step in t_steps]
        if any(remain0):
            inds = np.where(remain0)[0][::-1]
            string = "\n".join([str(self.records[i]) for i in inds])
            warnings.warn("following ground-motion records excluded because of t_step:\n"+string)
            for i in inds:
                self.excluded.append(deepcopy(self.records[i]))
                del self.records[i]
    
    
    def check_duplicates(self):
        r0 = self.get_sas(0.)
        r0r = np.round(r0, 4)
        u, c = np.unique(r0r, return_counts=True)
        dup = u[c > 1]
        todelete = list()
        periods = [0.01, 0.05, 0.075, 0.1, 0.2, 0.5, 1., 2.]
        for d in tqdm(dup):
            inds = np.where(r0r == d)[0]
            sref = self.records[inds[0]].generate_response_spectrum(periods)
            for ind in inds[1:]:
                sche = self.records[ind].generate_response_spectrum(periods)
                # ax = self.records[inds[0]].plot_response_spectrum()
                # self.records[ind].plot_response_spectrum(ax=ax)
                if np.mean(np.power(sref-sche, 2)) < 1e-4:
                    todelete.append(ind)
        return todelete
    

    def delete_records(self, inds):
        if not hasattr(inds, '__iter__'):
            inds = [inds]
        inds = sorted(inds)
        for i in inds[::-1]:
            self.excluded.append(deepcopy(self.records[i]))
            for key in ["spectra", "interp_spectra"]:
                if self.records[i] in self.__dict__[key].keys():
                    del self.__dict__[key][self.records[i]]
            del self.records[i]
        for key in ["ims"]:
            for key2 in self.__dict__[key].keys():
                self.__dict__[key][key2] = np.delete(self.__dict__[key][key2], inds)

    
    @property
    def num_records(self):
        return len(self.records)


    def get_array(self, key):
        array = list()
        for rec in self.records:
            array.append( rec.__dict__[key] )
        return np.array(array)


    def get_sas(self, period):
        if period == 0.:
            key = "PGA"
        else:
            key = "SA({:.1f})".format(period)
        if key in self.ims.keys():
            return self.ims[key]
        ims = list()
        for rec in self.records:
            ims.append(rec.get_sa(period))
        self.ims[key] = np.array(ims)
        return self.ims[key]
    

    def get_avgsas_T(self, struct_period):
        key = "avgSA({:.2f})".format(struct_period)
        if key in self.ims.keys():
            return self.ims[key]
        ims = list()
        for rec in self.records:
            ims.append(rec.get_avgsa_T(struct_period))
        self.ims[key] = np.array(ims)
        return self.ims[key]

    
    def get_avgsas(self, lower_period, upper_period):
        key = "avgSA({:.2f},{:.2f})".format(lower_period, upper_period)
        if key in self.ims.keys():
            return self.ims[key]
        ims = list()
        for rec in self.records:
            ims.append(rec.get_avgsa(lower_period, upper_period))
        self.ims[key] = np.array(ims)
        return self.ims[key]
    
    
    def get_pair_combos(self, ims, plot=False, imt="IM (m/s2)"):
        ''' all pair combination '''
        _max = np.ceil(ims.max()*100)/100
        combos = list()
        for i1 in ims:
            for i2 in ims:
                combos.append([i1, i2])
        combos = np.array(combos)
        if plot:
            fig = plt.figure(figsize=(6,6))
            plt.scatter(combos[:,0], combos[:,1], s=5, edgecolor='k', linewidth=0.1)
            plt.xlabel("GM1 {}".format(imt))
            plt.ylabel("GM2 {}".format(imt))
            plt.show()
        return combos
    

    def get_distr_im(self, ims, numbins=50, plot=False, imt="IM (m/s2)"):
        ''' actual distribution of IMs '''
        _max = np.ceil(ims.max()*100)/100
        bins = np.linspace(0., _max, numbins+1)
        hist, _ = np.histogram(ims, bins=bins)
        actual_probs = hist/np.sum(hist)
        if plot:
            cents = bins[:-1] + np.diff(bins)/2
            fig, ax = plt.subplots(2,1)
            ax[0].bar(cents, actual_probs, width=0.95*np.diff(bins), edgecolor='k')
            ax[0].set_ylabel("PMF")
            # ax[0].set_yscale("log")
            ax[1].bar(cents, np.cumsum(actual_probs), width=0.95*np.diff(bins), edgecolor='k')
            ax[1].set_xlabel(imt)
            ax[1].set_ylabel("CDF")
            plt.show()            
        return actual_probs, bins


    def get_distr_indeces(self, ims, numbins=50):
        ''' actual distribution of IMs '''
        _, bins = self.get_distr_im(ims, numbins)
        indeces = list()
        for e, edge in enumerate(bins[:-1]):
            indeces.append(list())
            for i, val in enumerate(ims):
                if edge <= val < bins[e+1]:
                    indeces[-1].append(i)
        return indeces


    def sample1d_ind(self, ims, num=500):
        ''' sampling with with indeces '''
        ranges = np.linspace(-0.5, ims.shape[0]-0.5, num+1)
        inds = [int(np.round(np.random.uniform(rang, ranges[i+1]))) 
                for i, rang in enumerate(ranges[:-1])]
        sampled_ims = ims[inds]
        return sampled_ims
        
    
    def sample2d_ind(self, num=500, plot=False, imt="IM (m/s2)"):
        ''' 2d sampling with indeces '''
        ims = self.ref_ims
        ranges = np.linspace(-0.5, ims.shape[0]-0.5, num+1)
        inds1 = [int(np.round(np.random.uniform(rang, ranges[i+1])))
                 for i, rang in enumerate(ranges[:-1])]
        np.random.shuffle(inds1)
        inds2 = [int(np.round(np.random.uniform(rang, ranges[i+1])))
                 for i, rang in enumerate(ranges[:-1])]
        np.random.shuffle(inds2)
        sample2d = self.get_sample2d_inds(inds1, inds2)
        if plot:
            fig = plt.figure(figsize=(6,6))
            plt.scatter(sample2d[:,0], sample2d[:,1], s=5, edgecolor='k', linewidth=0.1)
            plt.xlabel("GM1 {}".format(imt))
            plt.ylabel("GM2 {}".format(imt))
            plt.show()
        return inds1, inds2, sample2d


    def sample1d_im(self, ims, num=500, numbins=50):
        ''' sampling with with IMs '''
        sampler = qmc.LatinHypercube(d=1)
        sample = sampler.random(n=num)
        # actual probability distribution of ims
        indeces = self.get_distr_indeces(ims, numbins=numbins)
        actual_probs, _ = self.get_distr_im(ims, numbins=numbins, plot=False)
        cumprobs = np.cumsum(actual_probs)
        # index
        inds1d = np.searchsorted(cumprobs, sample)
        sample1d = list()
        for row in inds1d:
            # sample CMF
            if len(indeces[row[0]]) == 0:
                stop
            ind = np.random.choice(indeces[row[0]])
            sample1d.append(ims[ind])
        sample1d = np.array(sample1d)
        return sample1d
        

    def sample2d_im(self, ims, num=500, numbins=50, plot=False, imt="IM (m/s2)"):
        ''' 2d Latin Hypercube with IMs '''
        sampler = qmc.LatinHypercube(d=2)
        sample = sampler.random(n=num)
        # qmc.discrepancy(sample)
        # actual probability distribution of ims
        indeces = self.get_distr_indeces(ims, numbins=numbins)
        actual_probs, _ = self.get_distr_im(ims, numbins=numbins, plot=False)
        cumprobs = np.cumsum(actual_probs)
        # index
        inds2d = np.searchsorted(cumprobs, sample)
        sample2d = list()
        for row in inds2d:
            # sample CMF twice
            temp = list()
            for i in range(0,2):
                if len(indeces[row[i]]) == 0:
                    stop
                ind = np.random.choice(indeces[row[i]])
                temp.append(ims[ind])
            sample2d.append(temp)
        sample2d = np.array(sample2d)
        if plot:
            # fig = plt.figure(figsize=(6,6))
            # plt.scatter(sample[:,0], sample[:,1], s=5, edgecolor='k', linewidth=0.1)
            # plt.xlabel("epsilon1")
            # plt.ylabel("epsilon2")
            # plt.show()
            fig = plt.figure(figsize=(6,6))
            plt.scatter(sample2d[:,0], sample2d[:,1], s=5, edgecolor='k', linewidth=0.1)
            plt.xlabel("GM1 {}".format(imt))
            plt.ylabel("GM2 {}".format(imt))
            plt.show()
        return sample2d
    
    
    def plot_all_spectra(self, unit="g", x_scale="linear"):
        fig, ax = plt.subplots()
        ax.set_xlabel("Period (s)")
        if unit == "g":
            ax.set_ylabel("Acceleration (g)")
        elif unit == "m/s2":
            ax.set_ylabel("Acceleration (m/s2)")
        else:
            raise Exception("unit can only be 'g' or 'm/s2'")
        for rec in self.records:
            spec = rec.get_spectrum()
            if unit == "g":
                spec[:,1] = spec[:,1]/9.81
            ax.plot(spec[:,0], spec[:,1], linewidth=0.5, color=[0.5,0.5,0.5])
        ax.set_xscale(x_scale)
        plt.show()
    
    
    #TODO the next four functions could be changed to callable dicts
    def get_durations(self):
        duration = list()
        for rec in self.records:
            duration.append( rec.duration )
        return np.array(duration)


    def get_sign_durations(self, start=0.05, end=0.95):
        sign_dur = list()
        for rec in self.records:
            sign_dur.append( rec.get_significant_duration(start, end) )
        return np.array(sign_dur)


    def filter_duration(self, cutoff=10):
        durs = self.get_durations()
        inds = np.where(durs < cutoff)[0]
        self.delete_records(inds.tolist())


    def filter_sign_duration(self, cutoff=5, start=0.05, end=0.95):
        durs = self.get_sign_durations(start, end)
        inds = np.where(durs < cutoff)[0]
        self.delete_records(inds.tolist())

    
    def get_max_ref_ims(self):
        return np.max(self.ref_ims)
    
    
    def set_fitness_arrays(self, ref_ims):
        self.ref_ims = ref_ims
        self._max_ref = self.get_max_ref_ims()
        self.rsns = self.get_array("rsn")

    
    @classmethod
    def decode_inds(cls, all_inds, n, astype=int):
        inds_gm1 = np.array(all_inds[:n]).flatten().astype(astype)
        inds_gm2 = np.array(all_inds[n:]).flatten().astype(astype)
        return inds_gm1, inds_gm2


    def get_sample2d_inds(self, inds_gm1, inds_gm2, sf_gm1=1., sf_gm2=1.):
        return np.vstack([sf_gm1*self.ref_ims[inds_gm1],
                          sf_gm2*self.ref_ims[inds_gm2]]).T


    def get_siteclass2d_inds(self, inds_gm1, inds_gm2):
        # site_class
        return np.vstack([self.siteclass2d[inds_gm1],
                          self.siteclass2d[inds_gm2]]).T


    @classmethod
    def evaluate_sample2d(cls, sample2d, immax=None):
        hist, _, _= np.histogram2d(sample2d[:,0], sample2d[:,1],
                                   bins=20, range=[[0.,immax], [0.,immax]])
        return cls.get_mse(hist)


    @classmethod
    def evaluate_siteclass2d(cls, siteclass2d):
        hist, _, _= np.histogram2d(siteclass2d[:,0], siteclass2d[:,1],
                                   bins=[-0.5,0.5,1.5,2.5,3.5,4.5])
        return cls.get_mse(hist)
    

    @classmethod
    def get_mse(cls, hist):
        # mean squared error
        matr = hist - np.mean(hist)
        matr[matr > np.mean(hist)] *= 10
        mse = np.square(matr).mean()
        if mse == 0:
            mse = 1e-3
        # num_nonzero = np.count_nonzero(hist)
        # tot_bins = hist.shape[0]*hist.shape[1]
        if False: #num_nonzero != tot_bins: # False: # as many bins as possible with a pair
            outliers1 = 1. + np.sum(hist - np.mean(hist) > 1.)
            outliers2 = 1. + 10*np.max(hist - np.mean(hist))
            return np.log((tot_bins - num_nonzero)*outliers1*outliers2*mse)
        else:
            return np.log(mse)

    
    def fitness_pair_unscaled(self, x):
        '''
        x is a 1d numpy array (n: num ground-motion pairs to be selected):
        [index GM1 * n, index GM2 * n]
        '''
        raise Exception("recheck and update this function before using it")
        n = int(len(x)/2)
        inds1, inds2 = self.decode_inds(x, n)
        inds = np.vstack([inds1, inds2]).T
        if np.unique(inds, axis=0).shape[0] != inds.shape[0]:
            return n + (inds.shape[0] - np.unique(inds, axis=0).shape[0])*n
        sample2d = self.get_sample2d_inds(inds1, inds2)
        return self.evaluate_sample2d(sample2d, self._max_ref+1e-3)
        
    
    def fitness_pair(self, x):
        '''
        x is a 1d numpy array:
        [index GM1 * n, index GM2 * n, scaling GM1 * n, scaling GM2 * n]
        '''
        raise Exception("recheck and update this function before using it")
        n = int(len(x)/4)
        inds1, inds2 = self.decode_inds(x[:2*n], n)
        inds = np.vstack([inds1, inds2]).T
        # check none of the "pairs" is composed by the same index for gm1 and gm2
        check1 = np.sum(inds[:,0] == inds[:,1])
        # check all "pairs" of (ind1,ind2) are unique
        check2 = inds.shape[0] - np.unique(inds, axis=0).shape[0]
        # check that at least 80% of inds1 are unique
        check3 = int(inds1.shape[0]*0.7) - np.unique(inds1).shape[0]
        # check that at least 80% of inds2 are unique
        check4 = int(inds2.shape[0]*0.7) - np.unique(inds2).shape[0]
        mult = 1.
        message = "ok"
        if check1 > 0:
            message = "check1"
            mult = 1+n*check1
        elif check2 > 0:
            message = "check2"
            mult = 1+n*check2
        elif check3 > 0:
            message = "check3"
            mult = 1+n*check3
        elif check4 > 0:
            message = "check4"
            mult = 1+n*check4
        sf1, sf2 = self.decode_inds(x[2*n:], n, float)
        sample2d = self.get_sample2d_inds(inds1, inds2, sf1, sf2)
        # check all ground motions are within the range
        if np.any(sample2d > self._max_ref+1e-3):
            message = "check5"
            mult = 1+1e2*n*(np.sum(sample2d > self._max_ref+1e-3))
        mse = self.evaluate_sample2d(sample2d, self._max_ref+1e-3) + np.log(mult)
        print(message, mse)
        return mse


    def fitness_pair_nga(self, x):
        '''
        x is a 1d numpy array:
        [index GM1 * n, index GM2 * n, scaling GM1 * n, scaling GM2 * n]
        '''
        n = int(len(x)/4)
        inds1, inds2 = self.decode_inds(x[:2*n], n)
        rsn1 = self.rsns[inds1]
        rsn2 = self.rsns[inds2]
        rsn = np.vstack([rsn1, rsn2]).T
        # check "pairs" must not contain the same rsn for gm1 and gm2
        check1 = np.sum(rsn[:,0] == rsn[:,1])
        # check all "pairs" of (rsn1,rsn2) must be unique
        check2 = rsn.shape[0] - np.unique(rsn, axis=0).shape[0]
        # # check that at least 70% of rsn for gm1 must be unique
        # check3 = int(rsn1.shape[0]*0.7) - np.unique(rsn1).shape[0]
        # # check that at least 70% of rsn for gm2 must be unique
        # check4 = int(rsn2.shape[0]*0.7) - np.unique(rsn2).shape[0]
        mult = 1.
        message = ""
        if check1 > 0:
            message += "check1 "
            mult = 1. + mult*n*check1
        if check2 > 0:
            message += "check2 "
            mult = 1. + mult*n*check2
        # if check3 > 0:
        #     message += "check3 "
        #     mult = 1. + mult*n*check3
        # if check4 > 0:
        #     message += "check4 "
        #     mult = 1. + mult*n*check4
        sf1, sf2 = self.decode_inds(x[2*n:], n, float)
        sample2d = self.get_sample2d_inds(inds1, inds2, sf1, sf2)
        # check all ground motions are within the range
        if np.any(sample2d > self._max_ref+1e-3):
            message += "check5 "
            mult = 1. + mult*n*(np.sum(sample2d > self._max_ref+1e-3))
        mse = self.evaluate_sample2d(sample2d, self._max_ref+1e-3) + np.log(mult)
        print(message, mse)
        return mse


    def fitness_pair_vs30(self, x):
        '''
        x is a 1d numpy array:
        [index GM1 * n, index GM2 * n, scaling GM1 * n, scaling GM2 * n]
        '''
        n = int(len(x)/4)
        inds1, inds2 = self.decode_inds(x[:2*n], n)
        inds = np.vstack([inds1, inds2]).T
        # unique pairs
        if np.unique(inds, axis=0).shape[0] != inds.shape[0]:
            return n + (inds.shape[0] - np.unique(inds, axis=0).shape[0])*n
        sf1, sf2 = self.decode_inds(x[2*n:], n, float)
        siteclass2d = self.get_siteclass2d_inds(inds1, inds2)
        sample2d = self.get_sample2d_inds(inds1, inds2, sf1, sf2)
        mse = self.evaluate_sample2d(sample2d, self._max_ref+1e-3)
        mse2 = self.evaluate_siteclass2d(siteclass2d)
        print(mse+mse2)
        return mse+mse2

    
    def __repr__(self):
        return self.__str__()
        
    def __str__(self):
        return "<{} ".format(self.__class__.__name__) + \
               str(self.num_records) + " records>"
   
    # def __iter__(self):
    #     self.__n = 0
    #     return self

    # def __next__(self):
    #     if self.__n < self.num_catalogs:
    #         ob = self[self.__n]
    #         self.__n += 1
    #         return ob
    #     else:
    #         raise StopIteration
    
    # def __getitem__(self, i):
    #     ob = self.gmf_catalogs[i]
    #     if isinstance(ob, list):
    #         for o in ob:
    #             if o.sites is None:
    #                 o.sites = self.sites
    #             if o.imts is None:
    #                 o.imts = self.imts
    #     else:
    #         if ob.sites is None:
    #             ob.sites = self.sites
    #         if ob.imts is None:
    #             ob.imts = self.imts
    #     return ob

        
    def simul_ann_simple(self, n=400):
        lw = [0] * 2*n
        up = [len(self.records)-1e-12] * 2*n
        bounds = list(zip(lw, up))
        ret = dual_annealing(self.fitness_pair_simple, bounds=bounds, maxiter=1000,
                              initial_temp=5230.0, restart_temp_ratio=2e-05, 
                              visit=2.62, accept=-5.0, maxfun=1e7,
                              no_local_search=False)
        inds1, inds2 = self.decode_inds(ret.x, n)
        return inds1, inds2
    
        
    def simul_ann(self, n=400):
        lw = [0] * 2*n + [0.5] * 2*n
        up = [len(self.records)-1e-12] * 2*n + [1.5] * 2*n 
        bounds = list(zip(lw, up))
        t = time.time()
        ret = dual_annealing(self.fitness_pair_nga, bounds=bounds, maxiter=1000,
                             initial_temp=5230.0, restart_temp_ratio=2e-05, 
                             visit=2.62, accept=-5.0, maxfun=1e7,
                             no_local_search=False)
        print("dual_annealing", time.time()-t, self.fitness_pair_nga(ret.x))
        inds1, inds2 = self.decode_inds(ret.x[:2*n], n)
        sf1, sf2 = self.decode_inds(ret.x[2*n:], n, float)
        sample2d = self.get_sample2d_inds(inds1, inds2, sf1, sf2)
        # modify
        while np.where(sample2d[:,1] > self._max_ref)[0].shape[0] != 0:
            ret.x[3*n+np.where(sample2d[:,1] > self._max_ref)[0]] -= 0.1
            inds1, inds2 = self.decode_inds(ret.x[:2*n], n)
            sf1, sf2 = self.decode_inds(ret.x[2*n:], n, float)
            sample2d = self.get_sample2d_inds(inds1, inds2, sf1, sf2)        
        while np.where(sample2d[:,0] > self._max_ref)[0].shape[0] != 0:
            ret.x[2*n+np.where(sample2d[:,0] > self._max_ref)[0]] -= 0.1
            inds1, inds2 = self.decode_inds(ret.x[:2*n], n)
            sf1, sf2 = self.decode_inds(ret.x[2*n:], n, float)
            sample2d = self.get_sample2d_inds(inds1, inds2, sf1, sf2) 
        return inds1, inds2, sf1, sf2, sample2d


    @classmethod
    def scatter(cls, array1, array2, xlabel="", ylabel=""):
        fig, ax = plt.subplots(figsize=(6,6))
        ax.scatter(array1, array2, s=20, linewidth=0.1, edgecolors='k', color='gray')
        ax.set_xlabel("GM1 "+xlabel)
        ax.set_ylabel("GM2 "+ylabel)
        plt.show()
        
        
    @classmethod
    def hist2d(cls, array2d, bar_width=1., range_bin=None, centered=False,
               xlabel="", ylabel=""):
        if range_bin is not None:
            hist, xedges, yedges = np.histogram2d(array2d[:,0], array2d[:,1],
                                             bins=20, range=[range_bin, range_bin])
        else:
            hist, xedges, yedges = np.histogram2d(array2d[:,0], array2d[:,1], bins=20)
        fig = plt.figure()
        ax = fig.add_subplot(projection='3d')
        if centered:
            xpos, ypos = np.meshgrid(xedges[:-1] + np.min(np.diff(xedges))/2,
                                     yedges[:-1] + np.min(np.diff(yedges))/2, 
                                     indexing="ij")
        else:
            xpos, ypos = np.meshgrid(xedges[:-1], xedges[:-1], indexing="ij")
        xpos = xpos.ravel()
        ypos = ypos.ravel()
        zpos = 0
        dx = dy = bar_width*np.ones_like(zpos)
        dz = hist.ravel()
        ax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')
        ax.set_xlabel("GM1 "+xlabel)
        ax.set_ylabel("GM2 "+ylabel)
        plt.show()
    



    # siteclass2d = rc.get_siteclass2d_inds(inds1, inds2)
    # hist2, xedges2, yedges2 = np.histogram2d(siteclass2d[:,0], siteclass2d[:,1],
    #                                bins=[-0.5,0.5,1.5,2.5,3.5,4.5])


    # fig = plt.figure()
    # ax = fig.add_subplot(projection='3d')
    # xpos, ypos = np.meshgrid(xedges2[:-1], xedges2[:-1], indexing="ij")
    # xpos = xpos.ravel()
    # ypos = ypos.ravel()
    # zpos = 0
    # dx = dy = np.ones_like(zpos)
    # dz = hist2.ravel()
    # ax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')
    # ax.set_xlabel("Site class GM1")
    # ax.set_ylabel("Site class GM2")
    # ax.set_xticks(range(5))
    # ax.set_xticklabels(["A","B","C","D","E"])
    # ax.set_yticks(range(5))
    # ax.set_yticklabels(["A","B","C","D","E"])
    # plt.show()
    
    
    # mags1 = rc.get_array("magnitude")[inds1]
    # dists1 = rc.get_array("epicentral_distance")[inds1]
    # mags2 = rc.get_array("magnitude")[inds2]
    # dists2 = rc.get_array("epicentral_distance")[inds2]

    
    # hist2, xedges2, yedges2 = np.histogram2d(mags1, mags2)
    # fig = plt.figure()
    # ax = fig.add_subplot(projection='3d')
    # xpos, ypos = np.meshgrid(xedges2[:-1], xedges2[:-1], indexing="ij")
    # xpos = xpos.ravel()
    # ypos = ypos.ravel()
    # zpos = 0
    # dx = dy = 0.2*np.ones_like(zpos)
    # dz = hist2.ravel()
    # ax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')
    # ax.set_xlabel("mag GM1")
    # ax.set_ylabel("mag GM2")
    # plt.show()    
    
    
    # hist2, xedges2, yedges2 = np.histogram2d(dists1, dists2)
    # fig = plt.figure()
    # ax = fig.add_subplot(projection='3d')
    # xpos, ypos = np.meshgrid(xedges2[:-1], xedges2[:-1], indexing="ij")
    # xpos = xpos.ravel()
    # ypos = ypos.ravel()
    # zpos = 0
    # dx = dy = 10*np.ones_like(zpos)
    # dz = hist2.ravel()
    # ax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')
    # ax.set_xlabel("dist GM1")
    # ax.set_ylabel("dist GM2")
    # plt.show()
    


   