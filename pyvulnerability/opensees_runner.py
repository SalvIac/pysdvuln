# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
import pandas as pd
from scipy import integrate
import matplotlib.pyplot as plt
import openseespy.opensees as ops
from pyvulnerability.base_sdof import (geometry, material_martins_silva,
                                       time_history_analysis)


class OpenseesRunner():
    
    PATH_CAP_CURVES = r"C:\Users\Salvatore\Dropbox\SalvIac\global_fragility_vulnerability\capacity/"
    # PATH_CAP_CURVES = r"C:\Users\Salvatore\Documents\GitHub\global_fragility_vulnerability\capacity/"
    DAMPING = 0.05
    DEGRADATION = True

    def __init__(self, class_name):
        '''
        class_name: string
        '''
        filepath = self.PATH_CAP_CURVES+class_name+".csv"
        self.class_name = class_name
        self.filepath = filepath
        capacity_curve = pd.read_csv(filepath).to_numpy()
        self.capacity_curve = capacity_curve


    def run(self, ground_motion):
        '''
        ground_motion: 2d numpy array
        '''
        ops.wipe()
        _, period = material_martins_silva(self.capacity_curve,
                                           degradation=self.DEGRADATION)
        geometry()
        output = time_history_analysis(ground_motion, self.DAMPING)
        self.output = output
        self.ground_motion = ground_motion
        return output

    
    def calculate_hyst_energy(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return integrate.trapezoid(self.output["force"][inds]*self.output["vel"][inds],
                                   self.output["time"][inds])


    def get_max_disp(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return np.max(np.abs(self.output["disp"][inds]))


    def plot_acc_disp(self):
        fig, axs = plt.subplots(nrows=2, sharex=True)
        axs[0].plot(self.output["time"], self.output["disp"], lw=1)
        axs[0].set_xlabel("Time (s)")
        axs[0].set_ylabel("Displacement (m)")
        axs[1].plot(self.output["time"], self.output["accel"], lw=1)
        axs[1].set_xlabel("Time (s)")
        axs[1].set_ylabel("Acceleration (m/s2)")
        plt.show()
        return axs
    

    def plot_force_disp(self):
        fig, axs = plt.subplots(2,1)
        axs[0].plot(self.output["disp"], self.output["force"], lw=1)
        axs[0].plot(self.capacity_curve[:,0], self.capacity_curve[:,1]*9.81, lw=1)
        axs[0].set_xlabel("Displacement (m)")
        axs[0].set_ylabel("Acceleration (m/s2)")
        axs[1].plot(self.output["time"], self.output["disp"], lw=1)
        axs[1].set_xlabel("Time (s)")
        axs[1].set_ylabel("Displacement (m)")
        plt.show()
        return axs

