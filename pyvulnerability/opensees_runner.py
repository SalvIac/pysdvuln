# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
import pandas as pd
from scipy import integrate
import matplotlib.pyplot as plt
import openseespy.opensees as ops
from pyvulnerability.base_sdof import BaseSDOF
bsd = BaseSDOF()


class OpenseesRunner():
    
    PATH_CAP_CURVES = r"C:\Users\Salvatore\Dropbox\SalvIac\global_fragility_vulnerability\capacity/"
    # PATH_CAP_CURVES = r"C:\Users\Salvatore\Documents\GitHub\global_fragility_vulnerability\capacity/"
    DAMPING = 0.05
    DEGRADATION = True

    def __init__(self, capacity_curve, mass=1., **kwargs):
        self.capacity_curve = capacity_curve
        self.__dict__.update(kwargs)
        self.mass = mass
        bsd.MASS = mass
    
    
    @classmethod
    def from_oq(cls, class_name):
        '''
        class_name: string
        '''
        filepath = cls.PATH_CAP_CURVES+class_name+".csv"
        capacity_curve = pd.read_csv(filepath).to_numpy()
        return cls(capacity_curve, class_name=class_name, filepath=filepath)


    def define_material(self, mat):
        if mat == "Pinching4":
            out = bsd.material_martins_silva(self.capacity_curve,
                                       degradation=self.DEGRADATION)
        elif mat == "Hysteretic":
            out = bsd.material_hysteretic(self.capacity_curve)
        elif mat == "Steel01":
            out = bsd.material_simple(self.capacity_curve)
        else:
            raise Exception("unsupported material type!")
        return out
    

    def run(self, ground_motion, mat="Pinching4"):
        '''
        ground_motion: 2d numpy array
        '''
        ops.wipe()
        _ = self.define_material(mat)
        bsd.geometry()
        output = bsd.time_history_analysis(ground_motion, self.DAMPING)
        self.output = output
        self.ground_motion = ground_motion
        return output
    
    
    def run_cyclic(self, mat="Pinching4", mode="increasing"):
        ops.wipe()
        _ = self.define_material(mat)
        bsd.geometry()
        if mode == "constant":
            time, sinewave = bsd.get_sinewave(amplitude=self.capacity_curve[-1,0]*0.9, dt=1e-2)
        elif mode == "increasing":
            ampls = np.linspace(0, self.capacity_curve[-1,0]*1.2, 1000)
            time, sinewave = bsd.get_sinewave(amplitude=ampls, dt=1e-2)
        else:
            raise Exception("check mode")
        output = bsd.cyclic_loading_analysis(sinewave)
        self.output = output
        self.output["time"] = time
        return output

    
    def calculate_hyst_energy(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return integrate.trapezoid(self.output["force"][inds]*self.output["vel"][inds],
                                   self.output["time"][inds])


    def get_max_disp(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return np.max(np.abs(self.output["disp"][inds]))


    def get_fund_period(self):
        '''
        mass [kg]
        capacity curve [g]
        displacement [m]
        '''
        return bsd.get_fund_period(self.capacity_curve)


    def plot_acc_disp_th(self, unit="m/s2"):
        fig, axs = plt.subplots(nrows=2, sharex=True)
        self.plot_disp_th(axs[0])
        self.plot_acc_th(unit, axs[1])
        plt.show()
        return axs
    
    
    def plot_disp_th(self, ax=None):
        if ax is None:
            fig, ax = plt.subplots()
        ax.plot(self.output["time"], self.output["disp"], lw=1)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Displacement (m)")
        if ax is not None:
            plt.show()
        return ax

            
    def plot_acc_th(self, unit="m/s2", ax=None):
        if ax is None:
            fig, ax = plt.subplots()
        if unit == "g":
            ax.plot(self.output["time"], self.output["accel"]/9.81, lw=1)
        else:
            ax.plot(self.output["time"], self.output["accel"], lw=1)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Acceleration ({})".format(unit))
        if ax is not None:
            plt.show()
        return ax
    

    def plot_force_disp_wth(self, ax2="acc", unit="m/s2"):
        fig, axs = plt.subplots(2,1)
        self.plot_force_disp(axs[0])
        if ax2 == "acc":
            self.plot_acc_th(unit, axs[1])
        elif ax2 == "disp":
            self.plot_disp_th(axs[1])
        else:
            raise Exception("check ax2")
        plt.show()
        return axs


    def plot_force_disp(self, ax=None):
        if ax is None:
            fig, ax = plt.subplots()
        ax.plot(self.output["disp"], self.output["force"], lw=1)
        ax.plot(self.capacity_curve[:,0], self.capacity_curve[:,1]*9.81*bsd.MASS, lw=1)
        ax.set_xlabel("Displacement (m)")
        ax.set_ylabel("Base shear (N per unit mass)")
        if ax is not None:
            plt.show()
        return ax


