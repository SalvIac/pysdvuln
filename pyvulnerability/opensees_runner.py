# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
import pandas as pd
from scipy import integrate
import matplotlib.pyplot as plt
import openseespy.opensees as ops
from pyvulnerability.base_sdof import BaseSDOF
from matplotlib.animation import FuncAnimation
bsd = BaseSDOF()


class OpenseesRunner():
    
    PATH_CAP_CURVES = r"C:\Users\Salvatore\Dropbox\SalvIac\global_fragility_vulnerability\capacity/"
    # PATH_CAP_CURVES = r"C:\Users\Salvatore\Documents\GitHub\global_fragility_vulnerability\capacity/"
    DAMPING = 0.05
    DEGRADATION = True

    def __init__(self, capacity_curve, mass=1., **kwargs):
        self.capacity_curve = capacity_curve
        self.__dict__.update(kwargs)
        self.mass = mass
        bsd.MASS = mass
    
    
    @classmethod
    def from_oq(cls, class_name):
        '''
        class_name: string
        '''
        filepath = cls.PATH_CAP_CURVES+class_name+".csv"
        capacity_curve = pd.read_csv(filepath).to_numpy()
        return cls(capacity_curve, class_name=class_name, filepath=filepath)


    def define_material(self, mat):
        if mat == "Pinching4":
            out = bsd.material_martins_silva(self.capacity_curve,
                                       degradation=self.DEGRADATION)
        elif mat == "Hysteretic":
            out = bsd.material_hysteretic(self.capacity_curve)
        elif mat == "Steel01":
            out = bsd.material_simple(self.capacity_curve)
        else:
            raise Exception("unsupported material type!")
        return out
    

    def run(self, ground_motion, mat="Pinching4"):
        '''
        ground_motion: 2d numpy array
        '''
        ops.wipe()
        _ = self.define_material(mat)
        bsd.geometry()
        output = bsd.time_history_analysis(ground_motion, self.DAMPING)
        self.output = output
        # self.ground_motion = ground_motion
        return output
    
    
    def run_cyclic(self, mat="Pinching4", mode="increasing"):
        ops.wipe()
        _ = self.define_material(mat)
        bsd.geometry()
        if mode == "constant":
            time, sinewave = bsd.get_sinewave(amplitude=self.capacity_curve[-1,0]*0.9, dt=1e-2)
        elif mode == "increasing":
            ampls = np.linspace(0, self.capacity_curve[-1,0]*1.2, 1000)
            time, sinewave = bsd.get_sinewave(amplitude=ampls, dt=1e-2)
        else:
            raise Exception("check mode")
        output = bsd.cyclic_loading_analysis(sinewave)
        self.output = output
        self.output["time"] = time
        return output

    
    def calculate_hyst_energy(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return integrate.trapezoid(self.output["force"][inds]*self.output["vel"][inds],
                                   self.output["time"][inds])


    def get_max_disp(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return np.max(np.abs(self.output["disp"][inds]))


    def get_fund_period(self):
        '''
        mass [kg]
        capacity curve [g]
        displacement [m]
        '''
        return bsd.get_fund_period(self.capacity_curve)


    def plot_acc_disp_th(self, unit="m/s2"):
        fig, axs = plt.subplots(nrows=2, sharex=True)
        self.plot_disp_th(axs[0])
        self.plot_acc_th(unit, axs[1])
        plt.show()
        return axs
    
    
    def plot_disp_th(self, ax=None, start_time=None, end_time=None):
        if ax is None:
            fig, ax = plt.subplots()
        ind = np.array([True]*len(self.output["time"]))
        if start_time is not None:
            ind = np.logical_and(ind, self.output["time"] >= start_time)
        if end_time is not None:
            ind = np.logical_and(ind, self.output["time"] < end_time)
        ax.plot(self.output["time"][ind], self.output["disp"][ind], lw=1)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Displacement (m)")
        if ax is not None:
            plt.show()
        return ax

            
    def plot_acc_th(self, unit="m/s2", ax=None, start_time=None, end_time=None):
        if ax is None:
            fig, ax = plt.subplots()
        ind = np.array([True]*len(self.output["time"]))
        if start_time is not None:
            ind = np.logical_and(ind, self.output["time"] >= start_time)
        if end_time is not None:
            ind = np.logical_and(ind, self.output["time"] < end_time)
        if unit == "g":
            ax.plot(self.output["time"][ind], self.output["accel"][ind]/9.81, lw=1)
        else:
            ax.plot(self.output["time"][ind], self.output["accel"][ind], lw=1)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Acceleration ({})".format(unit))
        if ax is not None:
            plt.show()
        return ax
    

    def plot_force_disp_wth(self, ax2="acc", unit="m/s2", start_time=None,
                            end_time=None):
        fig, axs = plt.subplots(2,1)
        self.plot_force_disp(axs[0], start_time, end_time)
        if ax2 == "acc":
            self.plot_acc_th(unit, axs[1], start_time, end_time)
        elif ax2 == "disp":
            self.plot_disp_th(axs[1], start_time, end_time)
        else:
            raise Exception("check ax2")
        plt.show()
        return axs


    def plot_force_disp(self, ax=None, start_time=None, end_time=None):
        if ax is None:
            fig, ax = plt.subplots()
        ind = np.array([True]*len(self.output["time"]))
        if start_time is not None:
            ind = np.logical_and(ind, self.output["time"] >= start_time)
        if end_time is not None:
            ind = np.logical_and(ind, self.output["time"] < end_time)
        ax.plot(self.output["disp"][ind], self.output["force"][ind], lw=1)
        ax.plot(self.capacity_curve[:,0], self.capacity_curve[:,1]*9.81*bsd.MASS,
                lw=1, color="k", ls="--")
        ax.plot(-self.capacity_curve[:,0], -self.capacity_curve[:,1]*9.81*bsd.MASS,
                lw=1, color="k", ls="--")
        ax.set_xlabel("Displacement (m)")
        ax.set_ylabel("Base shear (N per unit mass)")
        if ax is not None:
            plt.show()
        return ax
    
    
    def animate(self):
        raise Exception("incomplete")
        # animation
        fig, self.axs = plt.subplots(2,1, figsize=(8,12))
        if np.max(self.output["disp"]) > np.max(self.capacity_curve[:,0]):
            self.axs[0].set_xlim(np.min(self.output["disp"])*1.1,
                            np.max(self.output["disp"])*1.1)
        else:
            self.axs[0].set_xlim(-np.max(self.capacity_curve[:,0])*1.1,
                            np.max(self.capacity_curve[:,0])*1.1)
        self.axs[0].set_ylim(-np.max(self.capacity_curve[:,1])*9.81*bsd.MASS*1.1, 
                        np.max(self.capacity_curve[:,1])*9.81*bsd.MASS*1.1)
        self.axs[0].set_xlabel("Displacement (m)")
        self.axs[0].set_ylabel("Base shear (N)")
        self.axs[1].set_xlim(np.min(self.output["time"]), np.max(self.output["time"]))
        self.axs[1].set_ylim(np.min(self.output["accel"])/9.81*1.1, 
                        np.max(self.output["accel"])/9.81*1.1)
        self.axs[1].set_xlabel("Time (s)")
        self.axs[1].set_ylabel("Acceleration (g)")

        self.axs[0].plot(self.output["disp"], self.output["force"],
                    color=[0.7,0.7,0.7], lw=1)
        self.axs[1].plot(self.output["time"], self.output["accel"]/9.81,
                    color=[0.7,0.7,0.7], lw=1)
        self.axs[0].plot(self.capacity_curve[:,0], self.capacity_curve[:,1]*9.81*bsd.MASS,
                    lw=1, color="k", ls="--")
        self.axs[0].plot(-self.capacity_curve[:,0], -self.capacity_curve[:,1]*9.81*bsd.MASS,
                    lw=1, color="k", ls="--")
        self.anim = FuncAnimation(fig, self.animation_step,# init_func=init,
                                  frames=self.output["time"].shape[0],
                                  interval=5)#self.output["time"][1]-self.output["time"][0])

        
    def animation_step(self, i):
        self.axs[0].plot(self.output["disp"][:i], self.output["force"][:i],
                    color="b", lw=1) #, marker="o", markersize=2)
        self.axs[1].plot(self.output["time"][:i], self.output["accel"][:i]/9.81,
                    color="b", lw=1) #, marker="o", markersize=2)
        

