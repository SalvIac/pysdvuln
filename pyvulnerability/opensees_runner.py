# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
import pandas as pd
from scipy import integrate
import matplotlib.pyplot as plt
import openseespy.opensees as ops
from pyvulnerability.base_sdof import (geometry, get_sinewave, get_fund_period,
                                       time_history_analysis,
                                       cyclic_loading_analysis, 
                                       material_martins_silva,
                                       material_hysteretic, material_simple)


class OpenseesRunner():
    
    PATH_CAP_CURVES = r"C:\Users\Salvatore\Dropbox\SalvIac\global_fragility_vulnerability\capacity/"
    # PATH_CAP_CURVES = r"C:\Users\Salvatore\Documents\GitHub\global_fragility_vulnerability\capacity/"
    DAMPING = 0.05
    DEGRADATION = True

    def __init__(self, capacity_curve, **kwargs):
        self.capacity_curve = capacity_curve
        self.__dict__.update(kwargs)

        
    @classmethod
    def from_oq(cls, class_name):
        '''
        class_name: string
        '''
        filepath = cls.PATH_CAP_CURVES+class_name+".csv"
        capacity_curve = pd.read_csv(filepath).to_numpy()
        return cls(capacity_curve, class_name=class_name, filepath=filepath)


    def define_material(self, mat):
        if mat == "Pinching4":
            out = material_martins_silva(self.capacity_curve,
                                       degradation=self.DEGRADATION)
        elif mat == "Hysteretic":
            out = material_hysteretic(self.capacity_curve)
        elif mat == "Steel01":
            out = material_simple(self.capacity_curve)
        else:
            raise Exception("unsupported material type!")
        return out
    

    def run(self, ground_motion, mat="Pinching4"):
        '''
        ground_motion: 2d numpy array
        '''
        ops.wipe()
        _ = self.define_material(mat)
        geometry()
        output = time_history_analysis(ground_motion, self.DAMPING)
        self.output = output
        self.ground_motion = ground_motion
        return output
    
    
    def run_cyclic(self, mat="Pinching4", mode="increasing"):
        ops.wipe()
        _ = self.define_material(mat)
        geometry()
        if mode == "constant":
            time, sinewave = get_sinewave(amplitude=self.capacity_curve[-1,0]*0.9, dt=1e-2)
        elif mode == "increasing":
            ampls = np.linspace(0, self.capacity_curve[-1,0]*1.2, 1000)
            time, sinewave = get_sinewave(amplitude=ampls, dt=1e-2)
        else:
            raise Exception("check mode")
        output = cyclic_loading_analysis(sinewave)
        self.output = output
        self.output["time"] = time
        return output

    
    def calculate_hyst_energy(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return integrate.trapezoid(self.output["force"][inds]*self.output["vel"][inds],
                                   self.output["time"][inds])


    def get_max_disp(self, start=None, end=None):
        if start is None:
            start = self.output["time"][0]-0.1
        if end is None:
            end = self.output["time"][-1]+0.1
        inds = np.logical_and(self.output["time"] >= start, self.output["time"] < end) 
        return np.max(np.abs(self.output["disp"][inds]))


    def plot_acc_disp(self):
        fig, axs = plt.subplots(nrows=2, sharex=True)
        axs[0].plot(self.output["time"], self.output["disp"], lw=1)
        axs[0].set_xlabel("Time (s)")
        axs[0].set_ylabel("Displacement (m)")
        axs[1].plot(self.output["time"], self.output["accel"], lw=1)
        axs[1].set_xlabel("Time (s)")
        axs[1].set_ylabel("Acceleration (m/s2)")
        plt.show()
        return axs
    

    def plot_force_disp(self):
        fig, axs = plt.subplots(2,1)
        axs[0].plot(self.output["disp"], self.output["force"], lw=1)
        axs[0].plot(self.capacity_curve[:,0], self.capacity_curve[:,1]*9.81, lw=1)
        axs[0].set_xlabel("Displacement (m)")
        axs[0].set_ylabel("Acceleration (m/s2)")
        axs[1].plot(self.output["time"], self.output["disp"], lw=1)
        axs[1].set_xlabel("Time (s)")
        axs[1].set_ylabel("Displacement (m)")
        plt.show()
        return axs


    def get_fund_period(self):
        '''
        mass [kg]
        capacity curve [g]
        displacement [m]
        '''
        return get_fund_period(self.capacity_curve)



