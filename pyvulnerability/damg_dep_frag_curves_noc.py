# -*- coding: utf-8 -*-
"""
@author: Salvatore Iacoletti
"""

import numpy as np
import pandas as pd
from scipy.stats import norm
import matplotlib.pyplot as plt
from matplotlib import cm


class DamgDepFragCurvesNoC():
    
    def __init__(self, psdm, dsc, plot=False):
        self.psdm = psdm
        # get rid of cases where there is collapse, and edp==0 (with tol)
        # filt = np.logical_and(psdm.nocoll_g2, psdm.ds_g2 != 0, edp > 1e-5)
        filt_g1 = np.logical_and(psdm.nocoll_g1, psdm.filt_en_g1)
        filt_g12 = np.logical_and(psdm.nocoll_g2, psdm.hysts_g12 > psdm.ZERO_TOL)
        # edp, maxds_g1 and ims_g2 for fragility
        _edp = psdm.hysts_g12[filt_g12]
        _maxds_g1 = psdm.maxds_g1[filt_g12]
        _ims_g2 = psdm.ims_g2[filt_g12]
        __edp = psdm.hysts_g1[filt_g1] # psdm.hysts_g1[filt_g1]
        __maxds_g1 = np.zeros_like(psdm.maxds_g1[filt_g1]) # psdm.maxds_g1[filt_g1]
        __ims_g2 = psdm.ims_g1[filt_g1] # np.zeros_like(psdm.ims_g1[filt_g1])
        edp = np.concatenate([_edp, __edp])
        maxds_g1 = np.concatenate([_maxds_g1, __maxds_g1])
        ims_g2 = np.concatenate([_ims_g2, __ims_g2])
        # evaluate psdm
        psd = psdm(maxds_g1, ims_g2)
        a = psdm.a
        b = psdm.b
        c0 = psdm.c0
        d = psdm.d
        m = psdm.m
        # sigma, residuals and beta
        self.sigma_psdm = np.sqrt(np.sum((np.log(edp) - np.log(psd))**2) / (len(edp)-2))
        self.residuals_edp = psd-edp
        self.beta  = self.sigma_psdm/d
        # hysteretic energy given damage state thresholds
        self.E_ds = dict()
        for ds in range(0,5):
            self.E_ds[ds] = a * dsc.get_ds_drift(ds) ** b
        # median values of fragility curves for DS-g2|DS-g1 (DS-g1==0, mainshock fragility)
        self.mus = dict()
        for ds1 in range(0,5):
            for ds2 in range(0,5):
                if ds2 > ds1:
                    self.mus[(ds1,ds2)] = ((self.E_ds[ds2] - self.E_ds[ds1]) / \
                                 (c0*(1 - m * dsc.get_ds_drift(ds1)))) ** (1/d)
        # plot cloud of points
        if plot:
            # 3d hysteretic energy GM1+GM2 vs max drift GM1 vs IMs GM2
            fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
            X = np.linspace(0, np.max(_ims_g2), 20)
            Y = np.linspace(0, np.max(_maxds_g1), 20)
            X, Y = np.meshgrid(X, Y)
            R = psdm(Y.flatten(), X.flatten())
            Z = R.reshape(X.shape)
            ax.plot_surface(X, Y, Z, cmap=cm.coolwarm, linewidth=0,
                            antialiased=False, alpha=0.5)
            ax.scatter(_ims_g2, _maxds_g1, _edp, s=2, color="m")
            ax.scatter(__ims_g2, __maxds_g1, __edp, s=2, color="b")
            xs = np.linspace(0., np.max(maxds_g1), 100)
            ax.plot([0.]*len(xs), xs, psdm.power_law(xs, a, b), color="k", 
                    lw=2, zorder=200)
            xs = np.linspace(0., np.max(_ims_g2), 100)
            ax.plot(xs, [0.]*len(xs), psdm.power_law(xs, c0, d), color="k",
                    lw=2, zorder=200)
            ax.set_xlabel('IM GM2')
            ax.set_ylabel('Max drift GM1')
            ax.set_zlabel('Total Hysteretic Energy')
            ax.view_init(elev=25, azim=-140)
            plt.show()
        
    
    def get_frag_params(self, ds2, ds1=0):
        '''
        ds1 = 0 returns the mainshock fragility
        ds1 != 0 returns the aftershock fragility for ds2
        '''
        if ds2 == 0:
            raise Exception("check ds2, it cannot be zero")
        return self.mus[(ds1, ds2)], self.beta
    
    
    def get_frags_params_df(self, unit="m/s2"):
        data = dict()
        for (ds1, ds2) in self.mus.keys():
            mu, beta = self.get_frag_params(ds2, ds1)
            if unit == "g":
                mu = mu/9.81
            if ds1 == 0:
                data["DS{}".format(ds2)] = mu
            else:
                data["DS{}|DS{}".format(ds2, ds1)] = mu
        data["beta"] = beta
        return pd.DataFrame(data, index=[0]).T
    
    
    def get_fragility(self, ims, ds2, ds1=0, unit="m/s2"):
        if unit == "g":
            ims = ims*9.81
        mu, beta = self.get_frag_params(ds2, ds1)
        return norm.cdf((np.log(ims) - np.log(mu))/beta)


    def get_fragilities(self, ims, unit="m/s2"):
        P_ds = dict()
        for (ds1, ds2) in self.mus.keys():
            P_ds[(ds1, ds2)] = self.get_fragility(ims, ds2, ds1, unit)
        return P_ds


    def plot_frag_all(self, unit="g", imt="IM"):
        if unit == "g":
            x_ims = np.logspace(np.log10(1e-3), np.log10(15), 100)
        else:
            x_ims = np.logspace(np.log10(1e-3*9.81), np.log10(150), 100)
        P_ds = self.get_fragilities(x_ims, unit)
        
        fig, ax = plt.subplots(figsize=(6,6))
        for (ds1, ds2) in P_ds.keys():
            if ds1 == 0:
                label = "DS"+str(ds2)
                ls = '-'
            else:
                label = "DS"+str(ds2)+"|DS"+str(ds1)
                ls = ["--", "-.", ":"][ds1-1]
            color = ["b", "m", "g", "r"][ds2-1]
            ax.plot(x_ims, P_ds[(ds1, ds2)], lw=1, ls=ls, color=color, label=label)
        ax.set_xlabel('{} ({})'.format(imt, unit))
        ax.set_ylabel('P(DS-G2 >= ds | IM, DS-G1)')
        ax.legend()
        ax.set_ylim(0.,1.)
        # ax.xlim(xmin=0)
        # ax.ylim(ymin=0)
        plt.show()
        return ax


    def plot_frag_ds(self, ds1_plot=0, unit="g", imt="IM"):
        '''
        ds1==0, i.e., mainshock fragility
        '''
        if unit == "g":
            x_ims = np.logspace(np.log10(1e-2), np.log10(15), 100)
        else:
            x_ims = np.logspace(np.log10(1e-2*9.81), np.log10(15*9.81), 100)
        P_ds = self.get_fragilities(x_ims, unit)
        
        fig, ax = plt.subplots(figsize=(6,6))
        for (ds1, ds2) in P_ds.keys():
            if ds1 == ds1_plot:
                if ds1 == 0:
                    label = "DS"+str(ds2)
                    ls = '-'
                else:
                    label = "DS"+str(ds2)+"|DS"+str(ds1)
                    ls = ["--", "-.", ":"][ds1-1]
                color = ["b", "m", "g", "r"][ds2-1]
                ax.plot(x_ims, P_ds[(ds1, ds2)], lw=1, ls=ls, color=color, label=label)
        ax.set_xlabel('{} ({})'.format(imt, unit))
        ax.set_ylabel('P(DS-G2 >= ds | IM, DS-G1)')
        ax.legend()
        ax.set_ylim(0.,1.)
        # ax.xlim(xmin=0)
        # ax.ylim(ymin=0)
        plt.show()
        return ax

    
    def check_plots(self, unit="m/s2", imt="IM"):
        self.plot_frag_all(unit, imt)
        
        plt.figure()
        plt.scatter(self.psdm.ims_g1, self.psdm.maxds_g1)
        plt.xscale('log')
        plt.yscale('log')
        
        # plt.figure()
        # plt.scatter(psdm.ims_g1[filt], psdm.maxds_g1[filt])
        # plt.xscale('log')
        # plt.yscale('log')
        
        plt.figure()
        plt.plot(range(len(self.residuals_edp)), self.residuals_edp, 's')
        
        plt.show()
        
    